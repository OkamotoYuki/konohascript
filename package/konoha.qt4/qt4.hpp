#include <qt4_common.hpp>


class QReadLocker;
class DummyQReadLocker;
class QPen;
class DummyQPen;
class QMatrix4x4;
class DummyQMatrix4x4;
class QByteArray;
class DummyQByteArray;
class QWebHistory;
class DummyQWebHistory;
class QHostAddress;
class DummyQHostAddress;
class QSizeF;
class DummyQSizeF;
class QAuthenticator;
class DummyQAuthenticator;
class QWebDatabase;
class DummyQWebDatabase;
class QSslCipher;
class DummyQSslCipher;
class QSslKey;
class DummyQSslKey;
class QSslConfiguration;
class DummyQSslConfiguration;
class QKeySequence;
class DummyQKeySequence;
class QLine;
class DummyQLine;
class QFontInfo;
class DummyQFontInfo;
class QFontMetricsF;
class DummyQFontMetricsF;
class QTextCodec;
class DummyQTextCodec;
class QWebElementCollection;
class DummyQWebElementCollection;
class QColor;
class DummyQColor;
class QLatin1Char;
class DummyQLatin1Char;
class QWhatsThis;
class DummyQWhatsThis;
class QStyleHintReturn;
class DummyQStyleHintReturn;
class QLibraryInfo;
class DummyQLibraryInfo;
class QTextFragment;
class DummyQTextFragment;
class QTextTableCell;
class DummyQTextTableCell;
class QFont;
class DummyQFont;
class QPrinterInfo;
class DummyQPrinterInfo;
class QMetaEnum;
class DummyQMetaEnum;
class QByteArrayMatcher;
class DummyQByteArrayMatcher;
class QLocale;
class DummyQLocale;
class QTileRules;
class DummyQTileRules;
class QAtomicInt;
class DummyQAtomicInt;
class QEasingCurve;
class DummyQEasingCurve;
class QColormap;
class DummyQColormap;
class QTextBoundaryFinder;
class DummyQTextBoundaryFinder;
class QMutexLocker;
class DummyQMutexLocker;
class QRegion;
class DummyQRegion;
class QEvent;
class DummyQEvent;
class QPoint;
class DummyQPoint;
class QMetaObject;
class DummyQMetaObject;
class QTextCursor;
class DummyQTextCursor;
class QSysInfo;
class DummyQSysInfo;
class QWebHitTestResult;
class DummyQWebHitTestResult;
class QSemaphore;
class DummyQSemaphore;
class QHostInfo;
class DummyQHostInfo;
class QNetworkCacheMetaData;
class DummyQNetworkCacheMetaData;
class QStandardItem;
class DummyQStandardItem;
class QDesktopServices;
class DummyQDesktopServices;
class QPainter;
class DummyQPainter;
class QImageWriter;
class DummyQImageWriter;
class QBitArray;
class DummyQBitArray;
class QAbstractFileEngineHandler;
class DummyQAbstractFileEngineHandler;
class QTextDocumentFragment;
class DummyQTextDocumentFragment;
class QPainterPath;
class DummyQPainterPath;
class QUuid;
class DummyQUuid;
class QCursor;
class DummyQCursor;
class QNetworkProxy;
class DummyQNetworkProxy;
class QPaintEngine;
class DummyQPaintEngine;
class QGraphicsLayoutItem;
class DummyQGraphicsLayoutItem;
class QTextBlockUserData;
class DummyQTextBlockUserData;
class QObject;
class DummyQObject;
class QGradient;
class DummyQGradient;
class QWriteLocker;
class DummyQWriteLocker;
class QWaitCondition;
class DummyQWaitCondition;
class QWebSecurityOrigin;
class DummyQWebSecurityOrigin;
class QSharedData;
class DummyQSharedData;
class QDate;
class DummyQDate;
class QNetworkRequest;
class DummyQNetworkRequest;
class QFontMetrics;
class DummyQFontMetrics;
class QNetworkAddressEntry;
class DummyQNetworkAddressEntry;
class QLayoutItem;
class DummyQLayoutItem;
class QToolTip;
class DummyQToolTip;
class QTextOption;
class DummyQTextOption;
class QPersistentModelIndex;
class DummyQPersistentModelIndex;
class QTransform;
class DummyQTransform;
class QNetworkInterface;
class DummyQNetworkInterface;
class QPixmapCache;
class DummyQPixmapCache;
class QProcessEnvironment;
class DummyQProcessEnvironment;
class QSystemLocale;
class DummyQSystemLocale;
class QModelIndex;
class DummyQModelIndex;
class QResource;
class DummyQResource;
class QQuaternion;
class DummyQQuaternion;
class QTreeWidgetItem;
class DummyQTreeWidgetItem;
class QAccessibleBridge;
class DummyQAccessibleBridge;
class QAccessible;
class DummyQAccessible;
class QMargins;
class DummyQMargins;
class QWebHistoryItem;
class DummyQWebHistoryItem;
class QPaintEngineState;
class DummyQPaintEngineState;
class QTextObjectInterface;
class DummyQTextObjectInterface;
class QSslError;
class DummyQSslError;
class QUndoCommand;
class DummyQUndoCommand;
class QAbstractFileEngine;
class DummyQAbstractFileEngine;
class QSizePolicy;
class DummyQSizePolicy;
class QTime;
class DummyQTime;
class QTextLength;
class DummyQTextLength;
class QBasicTimer;
class DummyQBasicTimer;
class QNetworkCookie;
class DummyQNetworkCookie;
class QNetworkConfiguration;
class DummyQNetworkConfiguration;
class QTextLayout;
class DummyQTextLayout;
class QStyleFactory;
class DummyQStyleFactory;
class QSystemSemaphore;
class DummyQSystemSemaphore;
class QDir;
class DummyQDir;
class QImageReader;
class DummyQImageReader;
class QRect;
class DummyQRect;
class QPaintDevice;
class DummyQPaintDevice;
class QDebug;
class DummyQDebug;
class QItemEditorFactory;
class DummyQItemEditorFactory;
class QStaticText;
class DummyQStaticText;
class QIconEngine;
class DummyQIconEngine;
class QGraphicsItem;
class DummyQGraphicsItem;
class QWebElement;
class DummyQWebElement;
class QPointF;
class DummyQPointF;
class QMetaProperty;
class DummyQMetaProperty;
class QTextItem;
class DummyQTextItem;
class QLatin1String;
class DummyQLatin1String;
class QUrlInfo;
class DummyQUrlInfo;
class QNetworkProxyFactory;
class DummyQNetworkProxyFactory;
class QRunnable;
class DummyQRunnable;
class QTextDocumentWriter;
class DummyQTextDocumentWriter;
class QTextBlock;
class DummyQTextBlock;
class QInputContextFactory;
class DummyQInputContextFactory;
class QPalette;
class DummyQPalette;
class QDateTime;
class DummyQDateTime;
class QUrl;
class DummyQUrl;
class QRectF;
class DummyQRectF;
class QGenericArgument;
class DummyQGenericArgument;
class QPainterPathStroker;
class DummyQPainterPathStroker;
class QTextFormat;
class DummyQTextFormat;
class QRegExp;
class DummyQRegExp;
class QWebSettings;
class DummyQWebSettings;
class QMutex;
class DummyQMutex;
class QIcon;
class DummyQIcon;
class QCryptographicHash;
class DummyQCryptographicHash;
class QPrintEngine;
class DummyQPrintEngine;
class QReadWriteLock;
class DummyQReadWriteLock;
class QNetworkProxyQuery;
class DummyQNetworkProxyQuery;
class QTextDecoder;
class DummyQTextDecoder;
class QLineF;
class DummyQLineF;
class QElapsedTimer;
class DummyQElapsedTimer;
class QMetaClassInfo;
class DummyQMetaClassInfo;
class QTextLine;
class DummyQTextLine;
class QBrush;
class DummyQBrush;
class QTextInlineObject;
class DummyQTextInlineObject;
class QChar;
class DummyQChar;
class QFontDatabase;
class DummyQFontDatabase;
class QTextEncoder;
class DummyQTextEncoder;
class QStyleOption;
class DummyQStyleOption;
class QMetaMethod;
class DummyQMetaMethod;
class QSize;
class DummyQSize;
class QSslCertificate;
class DummyQSslCertificate;
class QGraphicsAnchor;
class DummyQGraphicsAnchor;
class QAbstractNetworkCache;
class DummyQAbstractNetworkCache;
class QNetworkConfigurationManager;
class DummyQNetworkConfigurationManager;
class QUndoStack;
class DummyQUndoStack;
class QInputContext;
class DummyQInputContext;
class QShortcutEvent;
class DummyQShortcutEvent;
class QStyleOptionTabBarBase;
class DummyQStyleOptionTabBarBase;
class QIconDragEvent;
class DummyQIconDragEvent;
class QGesture;
class DummyQGesture;
class QWebFrame;
class DummyQWebFrame;
class QStyleOptionToolBar;
class DummyQStyleOptionToolBar;
class QDragLeaveEvent;
class DummyQDragLeaveEvent;
class QHttp;
class DummyQHttp;
class QStyleOptionButton;
class DummyQStyleOptionButton;
class QStyleOptionFocusRect;
class DummyQStyleOptionFocusRect;
class QStyleOptionHeader;
class DummyQStyleOptionHeader;
class QStyleHintReturnVariant;
class DummyQStyleHintReturnVariant;
class QSignalMapper;
class DummyQSignalMapper;
class QCompleter;
class DummyQCompleter;
class QTextFrameFormat;
class DummyQTextFrameFormat;
class QShowEvent;
class DummyQShowEvent;
class QSound;
class DummyQSound;
class QObjectCleanupHandler;
class DummyQObjectCleanupHandler;
class QGraphicsPixmapItem;
class DummyQGraphicsPixmapItem;
class QFocusEvent;
class DummyQFocusEvent;
class QStyleOptionProgressBar;
class DummyQStyleOptionProgressBar;
class QActionEvent;
class DummyQActionEvent;
class QAccessibleEvent;
class DummyQAccessibleEvent;
class QDataWidgetMapper;
class DummyQDataWidgetMapper;
class QPrinter;
class DummyQPrinter;
class QStatusTipEvent;
class DummyQStatusTipEvent;
class QTimerEvent;
class DummyQTimerEvent;
class QGenericReturnArgument;
class DummyQGenericReturnArgument;
class QImage;
class DummyQImage;
class QAbstractState;
class DummyQAbstractState;
class QNetworkSession;
class DummyQNetworkSession;
class QActionGroup;
class DummyQActionGroup;
class QAbstractGraphicsShapeItem;
class DummyQAbstractGraphicsShapeItem;
class QIconEngineV2;
class DummyQIconEngineV2;
class QHideEvent;
class DummyQHideEvent;
class QResizeEvent;
class DummyQResizeEvent;
class QNetworkAccessManager;
class DummyQNetworkAccessManager;
class QAbstractItemDelegate;
class DummyQAbstractItemDelegate;
class QMoveEvent;
class DummyQMoveEvent;
class QGraphicsScene;
class DummyQGraphicsScene;
class QGraphicsSceneEvent;
class DummyQGraphicsSceneEvent;
class QStyleOptionToolBox;
class DummyQStyleOptionToolBox;
class QDrag;
class DummyQDrag;
class QPolygonF;
class DummyQPolygonF;
class QGraphicsEffect;
class DummyQGraphicsEffect;
class QLibrary;
class DummyQLibrary;
class QNetworkCookieJar;
class DummyQNetworkCookieJar;
class QAbstractTextDocumentLayout;
class DummyQAbstractTextDocumentLayout;
class QIODevice;
class DummyQIODevice;
class QThreadPool;
class DummyQThreadPool;
class QCloseEvent;
class DummyQCloseEvent;
class QStylePainter;
class DummyQStylePainter;
class QHelpEvent;
class DummyQHelpEvent;
class QStyle;
class DummyQStyle;
class QTextObject;
class DummyQTextObject;
class QTextCharFormat;
class DummyQTextCharFormat;
class QGestureEvent;
class DummyQGestureEvent;
class QAccessibleInterface;
class DummyQAccessibleInterface;
class QStyleOptionTab;
class DummyQStyleOptionTab;
class QWebPage;
class DummyQWebPage;
class QStyleHintReturnMask;
class DummyQStyleHintReturnMask;
class QStyleOptionDockWidget;
class DummyQStyleOptionDockWidget;
class QAbstractEventDispatcher;
class DummyQAbstractEventDispatcher;
class QPolygon;
class DummyQPolygon;
class QGraphicsLayout;
class DummyQGraphicsLayout;
class QStyleOptionRubberBand;
class DummyQStyleOptionRubberBand;
class QEventLoop;
class DummyQEventLoop;
class QMovie;
class DummyQMovie;
class QChildEvent;
class DummyQChildEvent;
class QMimeData;
class DummyQMimeData;
class QTimeLine;
class DummyQTimeLine;
class QAction;
class DummyQAction;
class QGraphicsLineItem;
class DummyQGraphicsLineItem;
class QAbstractTransition;
class DummyQAbstractTransition;
class QGraphicsItemGroup;
class DummyQGraphicsItemGroup;
class QGraphicsTransform;
class DummyQGraphicsTransform;
class QAbstractItemModel;
class DummyQAbstractItemModel;
class QPaintEvent;
class DummyQPaintEvent;
class QHoverEvent;
class DummyQHoverEvent;
class QValidator;
class DummyQValidator;
class QSystemTrayIcon;
class DummyQSystemTrayIcon;
class QInputMethodEvent;
class DummyQInputMethodEvent;
class QWindowStateChangeEvent;
class DummyQWindowStateChangeEvent;
class QConicalGradient;
class DummyQConicalGradient;
class QStyleOptionMenuItem;
class DummyQStyleOptionMenuItem;
class QStyleOptionComplex;
class DummyQStyleOptionComplex;
class QLayout;
class DummyQLayout;
class QGraphicsObject;
class DummyQGraphicsObject;
class QUndoGroup;
class DummyQUndoGroup;
class QWidget;
class DummyQWidget;
class QPixmap;
class DummyQPixmap;
class QLocalServer;
class DummyQLocalServer;
class QWidgetItem;
class DummyQWidgetItem;
class QStyleOptionGraphicsItem;
class DummyQStyleOptionGraphicsItem;
class QStyleOptionViewItem;
class DummyQStyleOptionViewItem;
class QWhatsThisClickedEvent;
class DummyQWhatsThisClickedEvent;
class QPicture;
class DummyQPicture;
class QButtonGroup;
class DummyQButtonGroup;
class QFtp;
class DummyQFtp;
class QTimer;
class DummyQTimer;
class QRadialGradient;
class DummyQRadialGradient;
class QSocketNotifier;
class DummyQSocketNotifier;
class QLinearGradient;
class DummyQLinearGradient;
class QDynamicPropertyChangeEvent;
class DummyQDynamicPropertyChangeEvent;
class QInputEvent;
class DummyQInputEvent;
class QTcpServer;
class DummyQTcpServer;
class QThread;
class DummyQThread;
class QWebHistoryInterface;
class DummyQWebHistoryInterface;
class QCoreApplication;
class DummyQCoreApplication;
class QSpacerItem;
class DummyQSpacerItem;
class QTextBlockFormat;
class DummyQTextBlockFormat;
class QTranslator;
class DummyQTranslator;
class QSharedMemory;
class DummyQSharedMemory;
class QTextListFormat;
class DummyQTextListFormat;
class QShortcut;
class DummyQShortcut;
class QDropEvent;
class DummyQDropEvent;
class QStyleOptionFrame;
class DummyQStyleOptionFrame;
class QStyleOptionTabWidgetFrame;
class DummyQStyleOptionTabWidgetFrame;
class QTextDocument;
class DummyQTextDocument;
class QStyleOptionComboBox;
class DummyQStyleOptionComboBox;
class QStyleOptionToolBoxV2;
class DummyQStyleOptionToolBoxV2;
class QStandardItemModel;
class DummyQStandardItemModel;
class QGraphicsSceneHelpEvent;
class DummyQGraphicsSceneHelpEvent;
class QBoxLayout;
class DummyQBoxLayout;
class QPrintPreviewWidget;
class DummyQPrintPreviewWidget;
class QTapAndHoldGesture;
class DummyQTapAndHoldGesture;
class QDesktopWidget;
class DummyQDesktopWidget;
class QLineEdit;
class DummyQLineEdit;
class QGraphicsAnchorLayout;
class DummyQGraphicsAnchorLayout;
class QDoubleValidator;
class DummyQDoubleValidator;
class QDirModel;
class DummyQDirModel;
class QGraphicsSceneDragDropEvent;
class DummyQGraphicsSceneDragDropEvent;
class QTouchEvent;
class DummyQTouchEvent;
class QGraphicsColorizeEffect;
class DummyQGraphicsColorizeEffect;
class QMenu;
class DummyQMenu;
class QFrame;
class DummyQFrame;
class QSignalTransition;
class DummyQSignalTransition;
class QStyleOptionTabBarBaseV2;
class DummyQStyleOptionTabBarBaseV2;
class QWebView;
class DummyQWebView;
class QRubberBand;
class DummyQRubberBand;
class QGraphicsRectItem;
class DummyQGraphicsRectItem;
class QState;
class DummyQState;
class QMainWindow;
class DummyQMainWindow;
class QAbstractListModel;
class DummyQAbstractListModel;
class QTextTableCellFormat;
class DummyQTextTableCellFormat;
class QGraphicsOpacityEffect;
class DummyQGraphicsOpacityEffect;
class QTextFrame;
class DummyQTextFrame;
class QGraphicsSceneMoveEvent;
class DummyQGraphicsSceneMoveEvent;
class QGraphicsDropShadowEffect;
class DummyQGraphicsDropShadowEffect;
class QContextMenuEvent;
class DummyQContextMenuEvent;
class QFinalState;
class DummyQFinalState;
class QDialogButtonBox;
class DummyQDialogButtonBox;
class QStyledItemDelegate;
class DummyQStyledItemDelegate;
class QGridLayout;
class DummyQGridLayout;
class QStyleOptionProgressBarV2;
class DummyQStyleOptionProgressBarV2;
class QLocalSocket;
class DummyQLocalSocket;
class QGraphicsScale;
class DummyQGraphicsScale;
class QGraphicsLinearLayout;
class DummyQGraphicsLinearLayout;
class QAbstractProxyModel;
class DummyQAbstractProxyModel;
class QCalendarWidget;
class DummyQCalendarWidget;
class QAbstractSlider;
class DummyQAbstractSlider;
class QRegExpValidator;
class DummyQRegExpValidator;
class QAbstractTableModel;
class DummyQAbstractTableModel;
class QStatusBar;
class DummyQStatusBar;
class QKeyEvent;
class DummyQKeyEvent;
class QAbstractButton;
class DummyQAbstractButton;
class QStyleOptionTitleBar;
class DummyQStyleOptionTitleBar;
class QDragMoveEvent;
class DummyQDragMoveEvent;
class QGraphicsPolygonItem;
class DummyQGraphicsPolygonItem;
class QComboBox;
class DummyQComboBox;
class QPlainTextDocumentLayout;
class DummyQPlainTextDocumentLayout;
class QTextTableFormat;
class DummyQTextTableFormat;
class QWizardPage;
class DummyQWizardPage;
class QStyleOptionTabV2;
class DummyQStyleOptionTabV2;
class QStyleOptionSizeGrip;
class DummyQStyleOptionSizeGrip;
class QAbstractSocket;
class DummyQAbstractSocket;
class QStyleOptionViewItemV2;
class DummyQStyleOptionViewItemV2;
class QGraphicsTextItem;
class DummyQGraphicsTextItem;
class QGraphicsEllipseItem;
class DummyQGraphicsEllipseItem;
class QStyleOptionSpinBox;
class DummyQStyleOptionSpinBox;
class QStyleOptionToolButton;
class DummyQStyleOptionToolButton;
class QBitmap;
class DummyQBitmap;
class QNetworkDiskCache;
class DummyQNetworkDiskCache;
class QGroupBox;
class DummyQGroupBox;
class QStyleOptionGroupBox;
class DummyQStyleOptionGroupBox;
class QWidgetAction;
class DummyQWidgetAction;
class QTabBar;
class DummyQTabBar;
class QGraphicsSimpleTextItem;
class DummyQGraphicsSimpleTextItem;
class QEventTransition;
class DummyQEventTransition;
class QHistoryState;
class DummyQHistoryState;
class QBuffer;
class DummyQBuffer;
class QItemDelegate;
class DummyQItemDelegate;
class QToolBar;
class DummyQToolBar;
class QIntValidator;
class DummyQIntValidator;
class QProgressBar;
class DummyQProgressBar;
class QGraphicsSceneResizeEvent;
class DummyQGraphicsSceneResizeEvent;
class QGraphicsSceneMouseEvent;
class DummyQGraphicsSceneMouseEvent;
class QTapGesture;
class DummyQTapGesture;
class QWheelEvent;
class DummyQWheelEvent;
class QDockWidget;
class DummyQDockWidget;
class QSwipeGesture;
class DummyQSwipeGesture;
class QWebInspector;
class DummyQWebInspector;
class QTabletEvent;
class DummyQTabletEvent;
class QMdiSubWindow;
class DummyQMdiSubWindow;
class QGraphicsGridLayout;
class DummyQGraphicsGridLayout;
class QAccessibleObject;
class DummyQAccessibleObject;
class QTextBlockGroup;
class DummyQTextBlockGroup;
class QStyleOptionTabWidgetFrameV2;
class DummyQStyleOptionTabWidgetFrameV2;
class QStyleOptionFrameV2;
class DummyQStyleOptionFrameV2;
class QNetworkReply;
class DummyQNetworkReply;
class QSplitterHandle;
class DummyQSplitterHandle;
class QApplication;
class DummyQApplication;
class QGraphicsSceneHoverEvent;
class DummyQGraphicsSceneHoverEvent;
class QDialog;
class DummyQDialog;
class QGraphicsBlurEffect;
class DummyQGraphicsBlurEffect;
class QSizeGrip;
class DummyQSizeGrip;
class QProxyModel;
class DummyQProxyModel;
class QStyleOptionSlider;
class DummyQStyleOptionSlider;
class QSplashScreen;
class DummyQSplashScreen;
class QMenuBar;
class DummyQMenuBar;
class QAbstractSpinBox;
class DummyQAbstractSpinBox;
class QTextImageFormat;
class DummyQTextImageFormat;
class QCommonStyle;
class DummyQCommonStyle;
class QGraphicsRotation;
class DummyQGraphicsRotation;
class QFormLayout;
class DummyQFormLayout;
class QFocusFrame;
class DummyQFocusFrame;
class QProcess;
class DummyQProcess;
class QGraphicsSceneWheelEvent;
class DummyQGraphicsSceneWheelEvent;
class QTabWidget;
class DummyQTabWidget;
class QGraphicsWidget;
class DummyQGraphicsWidget;
class QPanGesture;
class DummyQPanGesture;
class QMouseEvent;
class DummyQMouseEvent;
class QWorkspace;
class DummyQWorkspace;
class QGraphicsPathItem;
class DummyQGraphicsPathItem;
class QPinchGesture;
class DummyQPinchGesture;
class QGraphicsSceneContextMenuEvent;
class DummyQGraphicsSceneContextMenuEvent;
class QWizard;
class DummyQWizard;
class QSlider;
class DummyQSlider;
class QPrintPreviewDialog;
class DummyQPrintPreviewDialog;
class QPushButton;
class DummyQPushButton;
class QStyleOptionFrameV3;
class DummyQStyleOptionFrameV3;
class QStyleOptionTabV3;
class DummyQStyleOptionTabV3;
class QScrollBar;
class DummyQScrollBar;
class QProxyStyle;
class DummyQProxyStyle;
class QAccessibleWidget;
class DummyQAccessibleWidget;
class QTextTable;
class DummyQTextTable;
class QTextList;
class DummyQTextList;
class QLabel;
class DummyQLabel;
class QToolBox;
class DummyQToolBox;
class QMotifStyle;
class DummyQMotifStyle;
class QRadioButton;
class DummyQRadioButton;
class QDragEnterEvent;
class DummyQDragEnterEvent;
class QLCDNumber;
class DummyQLCDNumber;
class QKeyEventTransition;
class DummyQKeyEventTransition;
class QToolButton;
class DummyQToolButton;
class QErrorMessage;
class DummyQErrorMessage;
class QCheckBox;
class DummyQCheckBox;
class QAbstractScrollArea;
class DummyQAbstractScrollArea;
class QDial;
class DummyQDial;
class QInputDialog;
class DummyQInputDialog;
class QTcpSocket;
class DummyQTcpSocket;
class QPageSetupDialog;
class DummyQPageSetupDialog;
class QColorDialog;
class DummyQColorDialog;
class QMouseEventTransition;
class DummyQMouseEventTransition;
class QDateTimeEdit;
class DummyQDateTimeEdit;
class QVBoxLayout;
class DummyQVBoxLayout;
class QStyleOptionViewItemV3;
class DummyQStyleOptionViewItemV3;
class QFontComboBox;
class DummyQFontComboBox;
class QUdpSocket;
class DummyQUdpSocket;
class QMessageBox;
class DummyQMessageBox;
class QProgressDialog;
class DummyQProgressDialog;
class QAbstractPrintDialog;
class DummyQAbstractPrintDialog;
class QGraphicsProxyWidget;
class DummyQGraphicsProxyWidget;
class QGraphicsWebView;
class DummyQGraphicsWebView;
class QSpinBox;
class DummyQSpinBox;
class QDoubleSpinBox;
class DummyQDoubleSpinBox;
class QHBoxLayout;
class DummyQHBoxLayout;
class QSplitter;
class DummyQSplitter;
class QFontDialog;
class DummyQFontDialog;
class QSortFilterProxyModel;
class DummyQSortFilterProxyModel;
class QScrollArea;
class DummyQScrollArea;
class QSslSocket;
class DummyQSslSocket;
class QTextEdit;
class DummyQTextEdit;
class QStyleOptionViewItemV4;
class DummyQStyleOptionViewItemV4;
class QCommandLinkButton;
class DummyQCommandLinkButton;
class QGraphicsView;
class DummyQGraphicsView;
class QAbstractItemView;
class DummyQAbstractItemView;
class QCDEStyle;
class DummyQCDEStyle;
class QMdiArea;
class DummyQMdiArea;
class QPlainTextEdit;
class DummyQPlainTextEdit;
class QPrintDialog;
class DummyQPrintDialog;
class QDateEdit;
class DummyQDateEdit;
class QTimeEdit;
class DummyQTimeEdit;
class QColumnView;
class DummyQColumnView;
class QTextBrowser;
class DummyQTextBrowser;
class QTableView;
class DummyQTableView;
class QTreeView;
class DummyQTreeView;
class QHeaderView;
class DummyQHeaderView;
class QTreeWidget;
class DummyQTreeWidget;

#ifndef QREADLOCKER
#define QREADLOCKER
class DummyQReadLocker {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQReadLocker();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQReadLocker : public QReadLocker {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQReadLocker *dummy;
	KQReadLocker(QReadWriteLock* lock);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QREADLOCKER



#ifndef QPEN
#define QPEN
class DummyQPen {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPen();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPen : public QPen {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPen *dummy;
	KQPen();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPEN



#ifndef QMATRIX4X4
#define QMATRIX4X4
class DummyQMatrix4x4 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQMatrix4x4();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQMatrix4x4 : public QMatrix4x4 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMatrix4x4 *dummy;
	KQMatrix4x4();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QMATRIX4X4



#ifndef QBYTEARRAY
#define QBYTEARRAY
class DummyQByteArray {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQByteArray();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQByteArray : public QByteArray {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQByteArray *dummy;
	KQByteArray();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QBYTEARRAY



#ifndef QWEBHISTORY
#define QWEBHISTORY
class DummyQWebHistory {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWebHistory();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWebHistory : public QWebHistory {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWebHistory *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QWEBHISTORY



#ifndef QHOSTADDRESS
#define QHOSTADDRESS
class DummyQHostAddress {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQHostAddress();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQHostAddress : public QHostAddress {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQHostAddress *dummy;
	KQHostAddress();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QHOSTADDRESS



#ifndef QSIZEF
#define QSIZEF
class DummyQSizeF {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSizeF();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSizeF : public QSizeF {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSizeF *dummy;
	KQSizeF();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSIZEF



#ifndef QAUTHENTICATOR
#define QAUTHENTICATOR
class DummyQAuthenticator {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAuthenticator();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAuthenticator : public QAuthenticator {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAuthenticator *dummy;
	KQAuthenticator();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QAUTHENTICATOR



#ifndef QWEBDATABASE
#define QWEBDATABASE
class DummyQWebDatabase {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWebDatabase();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWebDatabase : public QWebDatabase {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWebDatabase *dummy;
	KQWebDatabase(const QWebDatabase other);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QWEBDATABASE



#ifndef QSSLCIPHER
#define QSSLCIPHER
class DummyQSslCipher {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSslCipher();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSslCipher : public QSslCipher {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSslCipher *dummy;
	KQSslCipher();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSSLCIPHER



#ifndef QSSLKEY
#define QSSLKEY
class DummyQSslKey {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSslKey();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSslKey : public QSslKey {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSslKey *dummy;
	KQSslKey();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSSLKEY



#ifndef QSSLCONFIGURATION
#define QSSLCONFIGURATION
class DummyQSslConfiguration {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSslConfiguration();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSslConfiguration : public QSslConfiguration {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSslConfiguration *dummy;
	KQSslConfiguration();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSSLCONFIGURATION



#ifndef QKEYSEQUENCE
#define QKEYSEQUENCE
class DummyQKeySequence {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQKeySequence();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQKeySequence : public QKeySequence {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQKeySequence *dummy;
	KQKeySequence();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QKEYSEQUENCE



#ifndef QLINE
#define QLINE
class DummyQLine {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQLine();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQLine : public QLine {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQLine *dummy;
	KQLine();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QLINE



#ifndef QFONTINFO
#define QFONTINFO
class DummyQFontInfo {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQFontInfo();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQFontInfo : public QFontInfo {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQFontInfo *dummy;
	KQFontInfo(const QFont font);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QFONTINFO



#ifndef QFONTMETRICSF
#define QFONTMETRICSF
class DummyQFontMetricsF {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQFontMetricsF();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQFontMetricsF : public QFontMetricsF {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQFontMetricsF *dummy;
	KQFontMetricsF(const QFont font);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QFONTMETRICSF



#ifndef QTEXTCODEC
#define QTEXTCODEC
class DummyQTextCodec {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextCodec();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextCodec : public QTextCodec {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextCodec *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTCODEC



#ifndef QWEBELEMENTCOLLECTION
#define QWEBELEMENTCOLLECTION
class DummyQWebElementCollection {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWebElementCollection();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWebElementCollection : public QWebElementCollection {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWebElementCollection *dummy;
	KQWebElementCollection();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QWEBELEMENTCOLLECTION



#ifndef QCOLOR
#define QCOLOR
class DummyQColor {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQColor();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQColor : public QColor {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQColor *dummy;
	KQColor();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QCOLOR



#ifndef QLATIN1CHAR
#define QLATIN1CHAR
class DummyQLatin1Char {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQLatin1Char();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQLatin1Char : public QLatin1Char {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQLatin1Char *dummy;
	KQLatin1Char(char c);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QLATIN1CHAR



#ifndef QWHATSTHIS
#define QWHATSTHIS
class DummyQWhatsThis {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWhatsThis();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWhatsThis : public QWhatsThis {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWhatsThis *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QWHATSTHIS



#ifndef QSTYLEHINTRETURN
#define QSTYLEHINTRETURN
class DummyQStyleHintReturn {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleHintReturn();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleHintReturn : public QStyleHintReturn {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleHintReturn *dummy;
	KQStyleHintReturn(int version, int type);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEHINTRETURN



#ifndef QLIBRARYINFO
#define QLIBRARYINFO
class DummyQLibraryInfo {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQLibraryInfo();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQLibraryInfo : public QLibraryInfo {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQLibraryInfo *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QLIBRARYINFO



#ifndef QTEXTFRAGMENT
#define QTEXTFRAGMENT
class DummyQTextFragment {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextFragment();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextFragment : public QTextFragment {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextFragment *dummy;
	KQTextFragment();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTFRAGMENT



#ifndef QTEXTTABLECELL
#define QTEXTTABLECELL
class DummyQTextTableCell {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextTableCell();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextTableCell : public QTextTableCell {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextTableCell *dummy;
	KQTextTableCell();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTTABLECELL



#ifndef QFONT
#define QFONT
class DummyQFont {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQFont();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQFont : public QFont {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQFont *dummy;
	KQFont();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QFONT



#ifndef QPRINTERINFO
#define QPRINTERINFO
class DummyQPrinterInfo {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPrinterInfo();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPrinterInfo : public QPrinterInfo {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPrinterInfo *dummy;
	KQPrinterInfo();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPRINTERINFO



#ifndef QMETAENUM
#define QMETAENUM
class DummyQMetaEnum {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQMetaEnum();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQMetaEnum : public QMetaEnum {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMetaEnum *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QMETAENUM



#ifndef QBYTEARRAYMATCHER
#define QBYTEARRAYMATCHER
class DummyQByteArrayMatcher {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQByteArrayMatcher();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQByteArrayMatcher : public QByteArrayMatcher {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQByteArrayMatcher *dummy;
	KQByteArrayMatcher();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QBYTEARRAYMATCHER



#ifndef QLOCALE
#define QLOCALE
class DummyQLocale {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQLocale();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQLocale : public QLocale {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQLocale *dummy;
	KQLocale();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QLOCALE



#ifndef QTILERULES
#define QTILERULES
class DummyQTileRules {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTileRules();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTileRules : public QTileRules {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTileRules *dummy;
	KQTileRules(Qt::TileRule horizontalRule, Qt::TileRule verticalRule);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTILERULES



#ifndef QATOMICINT
#define QATOMICINT
class DummyQAtomicInt {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAtomicInt();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAtomicInt : public QAtomicInt {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAtomicInt *dummy;
	KQAtomicInt(int value);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QATOMICINT



#ifndef QEASINGCURVE
#define QEASINGCURVE
class DummyQEasingCurve {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQEasingCurve();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQEasingCurve : public QEasingCurve {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQEasingCurve *dummy;
	KQEasingCurve(QEasingCurve::Type type);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QEASINGCURVE



#ifndef QCOLORMAP
#define QCOLORMAP
class DummyQColormap {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQColormap();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQColormap : public QColormap {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQColormap *dummy;
	KQColormap(const QColormap colormap);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QCOLORMAP



#ifndef QTEXTBOUNDARYFINDER
#define QTEXTBOUNDARYFINDER
class DummyQTextBoundaryFinder {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextBoundaryFinder();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextBoundaryFinder : public QTextBoundaryFinder {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextBoundaryFinder *dummy;
	KQTextBoundaryFinder();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTBOUNDARYFINDER



#ifndef QMUTEXLOCKER
#define QMUTEXLOCKER
class DummyQMutexLocker {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQMutexLocker();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQMutexLocker : public QMutexLocker {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMutexLocker *dummy;
	KQMutexLocker(QMutex* mutex);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QMUTEXLOCKER



#ifndef QREGION
#define QREGION
class DummyQRegion {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQRegion();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQRegion : public QRegion {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQRegion *dummy;
	KQRegion();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QREGION



#ifndef QEVENT
#define QEVENT
class DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQEvent : public QEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQEvent *dummy;
	KQEvent(QEvent::Type type);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QEVENT



#ifndef QPOINT
#define QPOINT
class DummyQPoint {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPoint();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPoint : public QPoint {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPoint *dummy;
	KQPoint();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPOINT



#ifndef QMETAOBJECT
#define QMETAOBJECT
class DummyQMetaObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQMetaObject();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQMetaObject : public QMetaObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMetaObject *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QMETAOBJECT



#ifndef QTEXTCURSOR
#define QTEXTCURSOR
class DummyQTextCursor {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextCursor();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextCursor : public QTextCursor {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextCursor *dummy;
	KQTextCursor();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTCURSOR



#ifndef QSYSINFO
#define QSYSINFO
class DummyQSysInfo {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSysInfo();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSysInfo : public QSysInfo {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSysInfo *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSYSINFO



#ifndef QWEBHITTESTRESULT
#define QWEBHITTESTRESULT
class DummyQWebHitTestResult {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWebHitTestResult();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWebHitTestResult : public QWebHitTestResult {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWebHitTestResult *dummy;
	KQWebHitTestResult();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QWEBHITTESTRESULT



#ifndef QSEMAPHORE
#define QSEMAPHORE
class DummyQSemaphore {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSemaphore();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSemaphore : public QSemaphore {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSemaphore *dummy;
	KQSemaphore(int n);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSEMAPHORE



#ifndef QHOSTINFO
#define QHOSTINFO
class DummyQHostInfo {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQHostInfo();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQHostInfo : public QHostInfo {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQHostInfo *dummy;
	KQHostInfo(int id);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QHOSTINFO



#ifndef QNETWORKCACHEMETADATA
#define QNETWORKCACHEMETADATA
class DummyQNetworkCacheMetaData {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQNetworkCacheMetaData();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQNetworkCacheMetaData : public QNetworkCacheMetaData {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQNetworkCacheMetaData *dummy;
	KQNetworkCacheMetaData();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QNETWORKCACHEMETADATA



#ifndef QSTANDARDITEM
#define QSTANDARDITEM
class DummyQStandardItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStandardItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStandardItem : public QStandardItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStandardItem *dummy;
	KQStandardItem();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTANDARDITEM



#ifndef QDESKTOPSERVICES
#define QDESKTOPSERVICES
class DummyQDesktopServices {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQDesktopServices();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQDesktopServices : public QDesktopServices {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDesktopServices *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QDESKTOPSERVICES



#ifndef QPAINTER
#define QPAINTER
class DummyQPainter {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPainter();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPainter : public QPainter {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPainter *dummy;
	KQPainter();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPAINTER



#ifndef QIMAGEWRITER
#define QIMAGEWRITER
class DummyQImageWriter {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQImageWriter();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQImageWriter : public QImageWriter {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQImageWriter *dummy;
	KQImageWriter();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QIMAGEWRITER



#ifndef QBITARRAY
#define QBITARRAY
class DummyQBitArray {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQBitArray();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQBitArray : public QBitArray {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQBitArray *dummy;
	KQBitArray();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QBITARRAY



#ifndef QABSTRACTFILEENGINEHANDLER
#define QABSTRACTFILEENGINEHANDLER
class DummyQAbstractFileEngineHandler {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAbstractFileEngineHandler();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAbstractFileEngineHandler : public QAbstractFileEngineHandler {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractFileEngineHandler *dummy;
	KQAbstractFileEngineHandler();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QABSTRACTFILEENGINEHANDLER



#ifndef QTEXTDOCUMENTFRAGMENT
#define QTEXTDOCUMENTFRAGMENT
class DummyQTextDocumentFragment {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextDocumentFragment();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextDocumentFragment : public QTextDocumentFragment {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextDocumentFragment *dummy;
	KQTextDocumentFragment();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTDOCUMENTFRAGMENT



#ifndef QPAINTERPATH
#define QPAINTERPATH
class DummyQPainterPath {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPainterPath();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPainterPath : public QPainterPath {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPainterPath *dummy;
	KQPainterPath();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPAINTERPATH



#ifndef QUUID
#define QUUID
class DummyQUuid {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQUuid();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQUuid : public QUuid {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQUuid *dummy;
	KQUuid();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QUUID



#ifndef QCURSOR
#define QCURSOR
class DummyQCursor {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQCursor();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQCursor : public QCursor {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQCursor *dummy;
	KQCursor();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QCURSOR



#ifndef QNETWORKPROXY
#define QNETWORKPROXY
class DummyQNetworkProxy {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQNetworkProxy();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQNetworkProxy : public QNetworkProxy {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQNetworkProxy *dummy;
	KQNetworkProxy();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QNETWORKPROXY



#ifndef QPAINTENGINE
#define QPAINTENGINE
class DummyQPaintEngine {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPaintEngine();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPaintEngine : public QPaintEngine {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPaintEngine *dummy;
	KQPaintEngine(QPaintEngine::PaintEngineFeatures caps);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPAINTENGINE



#ifndef QGRAPHICSLAYOUTITEM
#define QGRAPHICSLAYOUTITEM
class DummyQGraphicsLayoutItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsLayoutItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsLayoutItem : public QGraphicsLayoutItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsLayoutItem *dummy;
	KQGraphicsLayoutItem(QGraphicsLayoutItem* parent, bool isLayout);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSLAYOUTITEM



#ifndef QTEXTBLOCKUSERDATA
#define QTEXTBLOCKUSERDATA
class DummyQTextBlockUserData {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextBlockUserData();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextBlockUserData : public QTextBlockUserData {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextBlockUserData *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTBLOCKUSERDATA



#ifndef QOBJECT
#define QOBJECT
class DummyQObject : public QObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *child_event_func;
	knh_Func_t *custom_event_func;
	knh_Func_t *timer_event_func;
	knh_Func_t *destroyed_func;
	DummyQObject();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
	bool childEventDummy(QChildEvent* event);
	bool customEventDummy(QEvent* event);
	bool timerEventDummy(QTimerEvent* event);
public slots:
	bool destroyedSlot(QObject* obj);
};

class KQObject : public QObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQObject *dummy;
	KQObject(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QOBJECT



#ifndef QGRADIENT
#define QGRADIENT
class DummyQGradient {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGradient();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGradient : public QGradient {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGradient *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRADIENT



#ifndef QWRITELOCKER
#define QWRITELOCKER
class DummyQWriteLocker {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWriteLocker();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWriteLocker : public QWriteLocker {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWriteLocker *dummy;
	KQWriteLocker(QReadWriteLock* lock);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QWRITELOCKER



#ifndef QWAITCONDITION
#define QWAITCONDITION
class DummyQWaitCondition {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWaitCondition();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWaitCondition : public QWaitCondition {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWaitCondition *dummy;
	KQWaitCondition();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QWAITCONDITION



#ifndef QWEBSECURITYORIGIN
#define QWEBSECURITYORIGIN
class DummyQWebSecurityOrigin {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWebSecurityOrigin();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWebSecurityOrigin : public QWebSecurityOrigin {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWebSecurityOrigin *dummy;
	KQWebSecurityOrigin(const QWebSecurityOrigin other);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QWEBSECURITYORIGIN



#ifndef QSHAREDDATA
#define QSHAREDDATA
class DummyQSharedData {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSharedData();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSharedData : public QSharedData {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSharedData *dummy;
	KQSharedData();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSHAREDDATA



#ifndef QDATE
#define QDATE
class DummyQDate {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQDate();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQDate : public QDate {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDate *dummy;
	KQDate();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QDATE



#ifndef QNETWORKREQUEST
#define QNETWORKREQUEST
class DummyQNetworkRequest {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQNetworkRequest();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQNetworkRequest : public QNetworkRequest {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQNetworkRequest *dummy;
	KQNetworkRequest(const QUrl url);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QNETWORKREQUEST



#ifndef QFONTMETRICS
#define QFONTMETRICS
class DummyQFontMetrics {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQFontMetrics();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQFontMetrics : public QFontMetrics {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQFontMetrics *dummy;
	KQFontMetrics(const QFont font);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QFONTMETRICS



#ifndef QNETWORKADDRESSENTRY
#define QNETWORKADDRESSENTRY
class DummyQNetworkAddressEntry {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQNetworkAddressEntry();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQNetworkAddressEntry : public QNetworkAddressEntry {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQNetworkAddressEntry *dummy;
	KQNetworkAddressEntry();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QNETWORKADDRESSENTRY



#ifndef QLAYOUTITEM
#define QLAYOUTITEM
class DummyQLayoutItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQLayoutItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQLayoutItem : public QLayoutItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQLayoutItem *dummy;
	KQLayoutItem(Qt::Alignment alignment);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QLAYOUTITEM



#ifndef QTOOLTIP
#define QTOOLTIP
class DummyQToolTip {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQToolTip();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQToolTip : public QToolTip {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQToolTip *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTOOLTIP



#ifndef QTEXTOPTION
#define QTEXTOPTION
class DummyQTextOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextOption();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextOption : public QTextOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextOption *dummy;
	KQTextOption();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTOPTION



#ifndef QPERSISTENTMODELINDEX
#define QPERSISTENTMODELINDEX
class DummyQPersistentModelIndex {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPersistentModelIndex();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPersistentModelIndex : public QPersistentModelIndex {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPersistentModelIndex *dummy;
	KQPersistentModelIndex(const QModelIndex index);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPERSISTENTMODELINDEX



#ifndef QTRANSFORM
#define QTRANSFORM
class DummyQTransform {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTransform();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTransform : public QTransform {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTransform *dummy;
	KQTransform();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTRANSFORM



#ifndef QNETWORKINTERFACE
#define QNETWORKINTERFACE
class DummyQNetworkInterface {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQNetworkInterface();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQNetworkInterface : public QNetworkInterface {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQNetworkInterface *dummy;
	KQNetworkInterface();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QNETWORKINTERFACE



#ifndef QPIXMAPCACHE
#define QPIXMAPCACHE
class DummyQPixmapCache {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPixmapCache();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPixmapCache : public QPixmapCache {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPixmapCache *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPIXMAPCACHE



#ifndef QPROCESSENVIRONMENT
#define QPROCESSENVIRONMENT
class DummyQProcessEnvironment {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQProcessEnvironment();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQProcessEnvironment : public QProcessEnvironment {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQProcessEnvironment *dummy;
	KQProcessEnvironment();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPROCESSENVIRONMENT



#ifndef QSYSTEMLOCALE
#define QSYSTEMLOCALE
class DummyQSystemLocale {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSystemLocale();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSystemLocale : public QSystemLocale {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSystemLocale *dummy;
	KQSystemLocale();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSYSTEMLOCALE



#ifndef QMODELINDEX
#define QMODELINDEX
class DummyQModelIndex {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQModelIndex();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQModelIndex : public QModelIndex {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQModelIndex *dummy;
	KQModelIndex();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QMODELINDEX



#ifndef QRESOURCE
#define QRESOURCE
class DummyQResource {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQResource();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQResource : public QResource {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQResource *dummy;
	KQResource(const QString file, const QLocale locale);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QRESOURCE



#ifndef QQUATERNION
#define QQUATERNION
class DummyQQuaternion {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQQuaternion();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQQuaternion : public QQuaternion {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQQuaternion *dummy;
	KQQuaternion();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QQUATERNION



#ifndef QTREEWIDGETITEM
#define QTREEWIDGETITEM
class DummyQTreeWidgetItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTreeWidgetItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTreeWidgetItem : public QTreeWidgetItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTreeWidgetItem *dummy;
	KQTreeWidgetItem(int type);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTREEWIDGETITEM



#ifndef QACCESSIBLEBRIDGE
#define QACCESSIBLEBRIDGE
class DummyQAccessibleBridge {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAccessibleBridge();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAccessibleBridge : public QAccessibleBridge {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAccessibleBridge *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QACCESSIBLEBRIDGE



#ifndef QACCESSIBLE
#define QACCESSIBLE
class DummyQAccessible {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAccessible();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAccessible : public QAccessible {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAccessible *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QACCESSIBLE



#ifndef QMARGINS
#define QMARGINS
class DummyQMargins {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQMargins();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQMargins : public QMargins {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMargins *dummy;
	KQMargins();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QMARGINS



#ifndef QWEBHISTORYITEM
#define QWEBHISTORYITEM
class DummyQWebHistoryItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWebHistoryItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWebHistoryItem : public QWebHistoryItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWebHistoryItem *dummy;
	KQWebHistoryItem(const QWebHistoryItem other);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QWEBHISTORYITEM



#ifndef QPAINTENGINESTATE
#define QPAINTENGINESTATE
class DummyQPaintEngineState {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPaintEngineState();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPaintEngineState : public QPaintEngineState {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPaintEngineState *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPAINTENGINESTATE



#ifndef QTEXTOBJECTINTERFACE
#define QTEXTOBJECTINTERFACE
class DummyQTextObjectInterface {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextObjectInterface();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextObjectInterface : public QTextObjectInterface {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextObjectInterface *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTOBJECTINTERFACE



#ifndef QSSLERROR
#define QSSLERROR
class DummyQSslError {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSslError();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSslError : public QSslError {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSslError *dummy;
	KQSslError();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSSLERROR



#ifndef QUNDOCOMMAND
#define QUNDOCOMMAND
class DummyQUndoCommand {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQUndoCommand();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQUndoCommand : public QUndoCommand {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQUndoCommand *dummy;
	KQUndoCommand(QUndoCommand* parent);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QUNDOCOMMAND



#ifndef QABSTRACTFILEENGINE
#define QABSTRACTFILEENGINE
class DummyQAbstractFileEngine {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAbstractFileEngine();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAbstractFileEngine : public QAbstractFileEngine {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractFileEngine *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QABSTRACTFILEENGINE



#ifndef QSIZEPOLICY
#define QSIZEPOLICY
class DummyQSizePolicy {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSizePolicy();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSizePolicy : public QSizePolicy {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSizePolicy *dummy;
	KQSizePolicy();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSIZEPOLICY



#ifndef QTIME
#define QTIME
class DummyQTime {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTime();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTime : public QTime {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTime *dummy;
	KQTime();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTIME



#ifndef QTEXTLENGTH
#define QTEXTLENGTH
class DummyQTextLength {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextLength();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextLength : public QTextLength {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextLength *dummy;
	KQTextLength();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTLENGTH



#ifndef QBASICTIMER
#define QBASICTIMER
class DummyQBasicTimer {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQBasicTimer();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQBasicTimer : public QBasicTimer {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQBasicTimer *dummy;
	KQBasicTimer();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QBASICTIMER



#ifndef QNETWORKCOOKIE
#define QNETWORKCOOKIE
class DummyQNetworkCookie {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQNetworkCookie();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQNetworkCookie : public QNetworkCookie {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQNetworkCookie *dummy;
	KQNetworkCookie(const QByteArray name, const QByteArray value);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QNETWORKCOOKIE



#ifndef QNETWORKCONFIGURATION
#define QNETWORKCONFIGURATION
class DummyQNetworkConfiguration {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQNetworkConfiguration();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQNetworkConfiguration : public QNetworkConfiguration {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQNetworkConfiguration *dummy;
	KQNetworkConfiguration();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QNETWORKCONFIGURATION



#ifndef QTEXTLAYOUT
#define QTEXTLAYOUT
class DummyQTextLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextLayout();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextLayout : public QTextLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextLayout *dummy;
	KQTextLayout();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTLAYOUT



#ifndef QSTYLEFACTORY
#define QSTYLEFACTORY
class DummyQStyleFactory {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleFactory();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleFactory : public QStyleFactory {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleFactory *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEFACTORY



#ifndef QSYSTEMSEMAPHORE
#define QSYSTEMSEMAPHORE
class DummyQSystemSemaphore {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSystemSemaphore();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSystemSemaphore : public QSystemSemaphore {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSystemSemaphore *dummy;
	KQSystemSemaphore(const QString key, int initialValue, QSystemSemaphore::AccessMode mode);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSYSTEMSEMAPHORE



#ifndef QDIR
#define QDIR
class DummyQDir {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQDir();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQDir : public QDir {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDir *dummy;
	KQDir(const QDir dir);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QDIR



#ifndef QIMAGEREADER
#define QIMAGEREADER
class DummyQImageReader {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQImageReader();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQImageReader : public QImageReader {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQImageReader *dummy;
	KQImageReader();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QIMAGEREADER



#ifndef QRECT
#define QRECT
class DummyQRect {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQRect();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQRect : public QRect {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQRect *dummy;
	KQRect();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QRECT



#ifndef QPAINTDEVICE
#define QPAINTDEVICE
class DummyQPaintDevice {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPaintDevice();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPaintDevice : public QPaintDevice {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPaintDevice *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPAINTDEVICE



#ifndef QDEBUG
#define QDEBUG
class DummyQDebug {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQDebug();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQDebug : public QDebug {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDebug *dummy;
	KQDebug(QIODevice* device);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QDEBUG



#ifndef QITEMEDITORFACTORY
#define QITEMEDITORFACTORY
class DummyQItemEditorFactory {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQItemEditorFactory();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQItemEditorFactory : public QItemEditorFactory {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQItemEditorFactory *dummy;
	KQItemEditorFactory();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QITEMEDITORFACTORY



#ifndef QSTATICTEXT
#define QSTATICTEXT
class DummyQStaticText {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStaticText();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStaticText : public QStaticText {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStaticText *dummy;
	KQStaticText();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTATICTEXT



#ifndef QICONENGINE
#define QICONENGINE
class DummyQIconEngine {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQIconEngine();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQIconEngine : public QIconEngine {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQIconEngine *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QICONENGINE



#ifndef QGRAPHICSITEM
#define QGRAPHICSITEM
class DummyQGraphicsItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *context_menu_event_func;
	knh_Func_t *drag_enter_event_func;
	knh_Func_t *drag_leave_event_func;
	knh_Func_t *drag_move_event_func;
	knh_Func_t *drop_event_func;
	knh_Func_t *focus_in_event_func;
	knh_Func_t *focus_out_event_func;
	knh_Func_t *hover_enter_event_func;
	knh_Func_t *hover_leave_event_func;
	knh_Func_t *hover_move_event_func;
	knh_Func_t *input_method_event_func;
	knh_Func_t *key_press_event_func;
	knh_Func_t *key_release_event_func;
	knh_Func_t *mouse_double_click_event_func;
	knh_Func_t *mouse_move_event_func;
	knh_Func_t *mouse_press_event_func;
	knh_Func_t *mouse_release_event_func;
	knh_Func_t *scene_event_func;
	knh_Func_t *wheel_event_func;
	DummyQGraphicsItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
	bool contextMenuEventDummy(QGraphicsSceneContextMenuEvent* event);
	bool dragEnterEventDummy(QGraphicsSceneDragDropEvent* event);
	bool dragLeaveEventDummy(QGraphicsSceneDragDropEvent* event);
	bool dragMoveEventDummy(QGraphicsSceneDragDropEvent* event);
	bool dropEventDummy(QGraphicsSceneDragDropEvent* event);
	bool focusInEventDummy(QFocusEvent* event);
	bool focusOutEventDummy(QFocusEvent* event);
	bool hoverEnterEventDummy(QGraphicsSceneHoverEvent* event);
	bool hoverLeaveEventDummy(QGraphicsSceneHoverEvent* event);
	bool hoverMoveEventDummy(QGraphicsSceneHoverEvent* event);
	bool inputMethodEventDummy(QInputMethodEvent* event);
	bool keyPressEventDummy(QKeyEvent* event);
	bool keyReleaseEventDummy(QKeyEvent* event);
	bool mouseDoubleClickEventDummy(QGraphicsSceneMouseEvent* event);
	bool mouseMoveEventDummy(QGraphicsSceneMouseEvent* event);
	bool mousePressEventDummy(QGraphicsSceneMouseEvent* event);
	bool mouseReleaseEventDummy(QGraphicsSceneMouseEvent* event);
	bool sceneEventDummy(QEvent* event);
	bool wheelEventDummy(QGraphicsSceneWheelEvent* event);
};

class KQGraphicsItem : public QGraphicsItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsItem *dummy;
	KQGraphicsItem(QGraphicsItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSITEM



#ifndef QWEBELEMENT
#define QWEBELEMENT
class DummyQWebElement {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWebElement();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWebElement : public QWebElement {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWebElement *dummy;
	KQWebElement();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QWEBELEMENT



#ifndef QPOINTF
#define QPOINTF
class DummyQPointF {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPointF();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPointF : public QPointF {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPointF *dummy;
	KQPointF();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPOINTF



#ifndef QMETAPROPERTY
#define QMETAPROPERTY
class DummyQMetaProperty {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQMetaProperty();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQMetaProperty : public QMetaProperty {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMetaProperty *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QMETAPROPERTY



#ifndef QTEXTITEM
#define QTEXTITEM
class DummyQTextItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextItem : public QTextItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextItem *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTITEM



#ifndef QLATIN1STRING
#define QLATIN1STRING
class DummyQLatin1String {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQLatin1String();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQLatin1String : public QLatin1String {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQLatin1String *dummy;
	KQLatin1String(const char* str);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QLATIN1STRING



#ifndef QURLINFO
#define QURLINFO
class DummyQUrlInfo {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQUrlInfo();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQUrlInfo : public QUrlInfo {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQUrlInfo *dummy;
	KQUrlInfo();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QURLINFO



#ifndef QNETWORKPROXYFACTORY
#define QNETWORKPROXYFACTORY
class DummyQNetworkProxyFactory {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQNetworkProxyFactory();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQNetworkProxyFactory : public QNetworkProxyFactory {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQNetworkProxyFactory *dummy;
	KQNetworkProxyFactory();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QNETWORKPROXYFACTORY



#ifndef QRUNNABLE
#define QRUNNABLE
class DummyQRunnable {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQRunnable();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQRunnable : public QRunnable {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQRunnable *dummy;
	KQRunnable();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QRUNNABLE



#ifndef QTEXTDOCUMENTWRITER
#define QTEXTDOCUMENTWRITER
class DummyQTextDocumentWriter {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextDocumentWriter();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextDocumentWriter : public QTextDocumentWriter {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextDocumentWriter *dummy;
	KQTextDocumentWriter();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTDOCUMENTWRITER



#ifndef QTEXTBLOCK
#define QTEXTBLOCK
class DummyQTextBlock {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextBlock();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextBlock : public QTextBlock {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextBlock *dummy;
	KQTextBlock(const QTextBlock other);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTBLOCK



#ifndef QINPUTCONTEXTFACTORY
#define QINPUTCONTEXTFACTORY
class DummyQInputContextFactory {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQInputContextFactory();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQInputContextFactory : public QInputContextFactory {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQInputContextFactory *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QINPUTCONTEXTFACTORY



#ifndef QPALETTE
#define QPALETTE
class DummyQPalette {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPalette();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPalette : public QPalette {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPalette *dummy;
	KQPalette();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPALETTE



#ifndef QDATETIME
#define QDATETIME
class DummyQDateTime {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQDateTime();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQDateTime : public QDateTime {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDateTime *dummy;
	KQDateTime();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QDATETIME



#ifndef QURL
#define QURL
class DummyQUrl {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQUrl();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQUrl : public QUrl {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQUrl *dummy;
	KQUrl();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QURL



#ifndef QRECTF
#define QRECTF
class DummyQRectF {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQRectF();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQRectF : public QRectF {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQRectF *dummy;
	KQRectF();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QRECTF



#ifndef QGENERICARGUMENT
#define QGENERICARGUMENT
class DummyQGenericArgument {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGenericArgument();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGenericArgument : public QGenericArgument {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGenericArgument *dummy;
	KQGenericArgument(const char* name, const void* data);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGENERICARGUMENT



#ifndef QPAINTERPATHSTROKER
#define QPAINTERPATHSTROKER
class DummyQPainterPathStroker {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPainterPathStroker();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPainterPathStroker : public QPainterPathStroker {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPainterPathStroker *dummy;
	KQPainterPathStroker();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPAINTERPATHSTROKER



#ifndef QTEXTFORMAT
#define QTEXTFORMAT
class DummyQTextFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextFormat();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextFormat : public QTextFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextFormat *dummy;
	KQTextFormat();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTFORMAT



#ifndef QREGEXP
#define QREGEXP
class DummyQRegExp {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQRegExp();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQRegExp : public QRegExp {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQRegExp *dummy;
	KQRegExp();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QREGEXP



#ifndef QWEBSETTINGS
#define QWEBSETTINGS
class DummyQWebSettings {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWebSettings();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWebSettings : public QWebSettings {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWebSettings *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QWEBSETTINGS



#ifndef QMUTEX
#define QMUTEX
class DummyQMutex {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQMutex();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQMutex : public QMutex {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMutex *dummy;
	KQMutex(QMutex::RecursionMode mode);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QMUTEX



#ifndef QICON
#define QICON
class DummyQIcon {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQIcon();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQIcon : public QIcon {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQIcon *dummy;
	KQIcon();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QICON



#ifndef QCRYPTOGRAPHICHASH
#define QCRYPTOGRAPHICHASH
class DummyQCryptographicHash {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQCryptographicHash();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQCryptographicHash : public QCryptographicHash {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQCryptographicHash *dummy;
	KQCryptographicHash(QCryptographicHash::Algorithm method);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QCRYPTOGRAPHICHASH



#ifndef QPRINTENGINE
#define QPRINTENGINE
class DummyQPrintEngine {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPrintEngine();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPrintEngine : public QPrintEngine {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPrintEngine *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPRINTENGINE



#ifndef QREADWRITELOCK
#define QREADWRITELOCK
class DummyQReadWriteLock {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQReadWriteLock();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQReadWriteLock : public QReadWriteLock {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQReadWriteLock *dummy;
	KQReadWriteLock();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QREADWRITELOCK



#ifndef QNETWORKPROXYQUERY
#define QNETWORKPROXYQUERY
class DummyQNetworkProxyQuery {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQNetworkProxyQuery();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQNetworkProxyQuery : public QNetworkProxyQuery {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQNetworkProxyQuery *dummy;
	KQNetworkProxyQuery();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QNETWORKPROXYQUERY



#ifndef QTEXTDECODER
#define QTEXTDECODER
class DummyQTextDecoder {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextDecoder();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextDecoder : public QTextDecoder {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextDecoder *dummy;
	KQTextDecoder(const QTextCodec* codec);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTDECODER



#ifndef QLINEF
#define QLINEF
class DummyQLineF {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQLineF();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQLineF : public QLineF {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQLineF *dummy;
	KQLineF();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QLINEF



#ifndef QELAPSEDTIMER
#define QELAPSEDTIMER
class DummyQElapsedTimer {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQElapsedTimer();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQElapsedTimer : public QElapsedTimer {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQElapsedTimer *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QELAPSEDTIMER



#ifndef QMETACLASSINFO
#define QMETACLASSINFO
class DummyQMetaClassInfo {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQMetaClassInfo();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQMetaClassInfo : public QMetaClassInfo {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMetaClassInfo *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QMETACLASSINFO



#ifndef QTEXTLINE
#define QTEXTLINE
class DummyQTextLine {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextLine();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextLine : public QTextLine {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextLine *dummy;
	KQTextLine();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTLINE



#ifndef QBRUSH
#define QBRUSH
class DummyQBrush {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQBrush();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQBrush : public QBrush {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQBrush *dummy;
	KQBrush();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QBRUSH



#ifndef QTEXTINLINEOBJECT
#define QTEXTINLINEOBJECT
class DummyQTextInlineObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextInlineObject();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextInlineObject : public QTextInlineObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextInlineObject *dummy;
	KQTextInlineObject(int i, QTextEngine* e);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTINLINEOBJECT



#ifndef QCHAR
#define QCHAR
class DummyQChar {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQChar();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQChar : public QChar {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQChar *dummy;
	KQChar();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QCHAR



#ifndef QFONTDATABASE
#define QFONTDATABASE
class DummyQFontDatabase {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQFontDatabase();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQFontDatabase : public QFontDatabase {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQFontDatabase *dummy;
	KQFontDatabase();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QFONTDATABASE



#ifndef QTEXTENCODER
#define QTEXTENCODER
class DummyQTextEncoder {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextEncoder();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextEncoder : public QTextEncoder {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextEncoder *dummy;
	KQTextEncoder(const QTextCodec* codec);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTENCODER



#ifndef QSTYLEOPTION
#define QSTYLEOPTION
class DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOption();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOption : public QStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOption *dummy;
	KQStyleOption(int version, int type);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTION



#ifndef QMETAMETHOD
#define QMETAMETHOD
class DummyQMetaMethod {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQMetaMethod();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQMetaMethod : public QMetaMethod {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMetaMethod *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QMETAMETHOD



#ifndef QSIZE
#define QSIZE
class DummyQSize {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSize();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSize : public QSize {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSize *dummy;
	KQSize();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSIZE



#ifndef QSSLCERTIFICATE
#define QSSLCERTIFICATE
class DummyQSslCertificate {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSslCertificate();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSslCertificate : public QSslCertificate {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSslCertificate *dummy;
	KQSslCertificate(QIODevice* device, QSsl::EncodingFormat format);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSSLCERTIFICATE



#ifndef QGRAPHICSANCHOR
#define QGRAPHICSANCHOR
class DummyQGraphicsAnchor : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsAnchor();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsAnchor : public QGraphicsAnchor {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsAnchor *dummy;

	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSANCHOR



#ifndef QABSTRACTNETWORKCACHE
#define QABSTRACTNETWORKCACHE
class DummyQAbstractNetworkCache : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAbstractNetworkCache();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAbstractNetworkCache : public QAbstractNetworkCache {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractNetworkCache *dummy;

	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTNETWORKCACHE



#ifndef QNETWORKCONFIGURATIONMANAGER
#define QNETWORKCONFIGURATIONMANAGER
class DummyQNetworkConfigurationManager : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *configuration_added_func;
	knh_Func_t *configuration_changed_func;
	knh_Func_t *configuration_removed_func;
	knh_Func_t *online_state_changed_func;
	knh_Func_t *update_completed_func;
	DummyQNetworkConfigurationManager();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool configurationAddedSlot(const QNetworkConfiguration config);
	bool configurationChangedSlot(const QNetworkConfiguration config);
	bool configurationRemovedSlot(const QNetworkConfiguration configuration);
	bool onlineStateChangedSlot(bool isOnline);
	bool updateCompletedSlot();
};

class KQNetworkConfigurationManager : public QNetworkConfigurationManager {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQNetworkConfigurationManager *dummy;
	KQNetworkConfigurationManager(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QNETWORKCONFIGURATIONMANAGER



#ifndef QUNDOSTACK
#define QUNDOSTACK
class DummyQUndoStack : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *can_redo_changed_func;
	knh_Func_t *can_undo_changed_func;
	knh_Func_t *clean_changed_func;
	knh_Func_t *index_changed_func;
	knh_Func_t *redo_text_changed_func;
	knh_Func_t *undo_text_changed_func;
	DummyQUndoStack();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool canRedoChangedSlot(bool canRedo);
	bool canUndoChangedSlot(bool canUndo);
	bool cleanChangedSlot(bool clean);
	bool indexChangedSlot(int idx);
	bool redoTextChangedSlot(const QString redoText);
	bool undoTextChangedSlot(const QString undoText);
};

class KQUndoStack : public QUndoStack {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQUndoStack *dummy;
	KQUndoStack(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QUNDOSTACK



#ifndef QINPUTCONTEXT
#define QINPUTCONTEXT
class DummyQInputContext : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQInputContext();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQInputContext : public QInputContext {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQInputContext *dummy;
	KQInputContext(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QINPUTCONTEXT



#ifndef QSHORTCUTEVENT
#define QSHORTCUTEVENT
class DummyQShortcutEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQShortcutEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQShortcutEvent : public QShortcutEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQShortcutEvent *dummy;
	KQShortcutEvent(const QKeySequence key, int id, bool ambiguous);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSHORTCUTEVENT



#ifndef QSTYLEOPTIONTABBARBASE
#define QSTYLEOPTIONTABBARBASE
class DummyQStyleOptionTabBarBase : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionTabBarBase();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionTabBarBase : public QStyleOptionTabBarBase {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionTabBarBase *dummy;
	KQStyleOptionTabBarBase();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONTABBARBASE



#ifndef QICONDRAGEVENT
#define QICONDRAGEVENT
class DummyQIconDragEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQIconDragEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQIconDragEvent : public QIconDragEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQIconDragEvent *dummy;
	KQIconDragEvent();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QICONDRAGEVENT



#ifndef QGESTURE
#define QGESTURE
class DummyQGesture : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGesture();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGesture : public QGesture {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGesture *dummy;
	KQGesture(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGESTURE



#ifndef QWEBFRAME
#define QWEBFRAME
class DummyQWebFrame : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *contents_size_changed_func;
	knh_Func_t *icon_changed_func;
	knh_Func_t *initial_layout_completed_func;
	knh_Func_t *java_script_window_object_cleared_func;
	knh_Func_t *load_finished_func;
	knh_Func_t *load_started_func;
	knh_Func_t *page_changed_func;
	knh_Func_t *title_changed_func;
	knh_Func_t *url_changed_func;
	DummyQWebFrame();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool contentsSizeChangedSlot(const QSize size);
	bool iconChangedSlot();
	bool initialLayoutCompletedSlot();
	bool javaScriptWindowObjectClearedSlot();
	bool loadFinishedSlot(bool ok);
	bool loadStartedSlot();
	bool pageChangedSlot();
	bool titleChangedSlot(const QString title);
	bool urlChangedSlot(const QUrl url);
};

class KQWebFrame {
// Q_OBJECT;
public:
	QWebFrame *q_self;
	knh_RawPtr_t *self;
	DummyQWebFrame *dummy;

	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QWEBFRAME



#ifndef QSTYLEOPTIONTOOLBAR
#define QSTYLEOPTIONTOOLBAR
class DummyQStyleOptionToolBar : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionToolBar();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionToolBar : public QStyleOptionToolBar {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionToolBar *dummy;
	KQStyleOptionToolBar();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONTOOLBAR



#ifndef QDRAGLEAVEEVENT
#define QDRAGLEAVEEVENT
class DummyQDragLeaveEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQDragLeaveEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQDragLeaveEvent : public QDragLeaveEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDragLeaveEvent *dummy;
	KQDragLeaveEvent();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QDRAGLEAVEEVENT



#ifndef QHTTP
#define QHTTP
class DummyQHttp : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *authentication_required_func;
	knh_Func_t *data_read_progress_func;
	knh_Func_t *data_send_progress_func;
	knh_Func_t *done_func;
	knh_Func_t *proxy_authentication_required_func;
	knh_Func_t *ready_read_func;
	knh_Func_t *request_finished_func;
	knh_Func_t *request_started_func;
	knh_Func_t *response_header_received_func;
	knh_Func_t *ssl_errors_func;
	knh_Func_t *state_changed_func;
	DummyQHttp();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool authenticationRequiredSlot(const QString hostname, quint16 port, QAuthenticator* authenticator);
	bool dataReadProgressSlot(int done, int total);
	bool dataSendProgressSlot(int done, int total);
	bool doneSlot(bool error);
	bool proxyAuthenticationRequiredSlot(const QNetworkProxy proxy, QAuthenticator* authenticator);
	bool readyReadSlot(const QHttpResponseHeader resp);
	bool requestFinishedSlot(int id, bool error);
	bool requestStartedSlot(int id);
	bool responseHeaderReceivedSlot(const QHttpResponseHeader resp);
	bool sslErrorsSlot(const QList<QSslError> errors);
	bool stateChangedSlot(int state);
};

class KQHttp : public QHttp {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQHttp *dummy;
	KQHttp(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QHTTP



#ifndef QSTYLEOPTIONBUTTON
#define QSTYLEOPTIONBUTTON
class DummyQStyleOptionButton : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionButton();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionButton : public QStyleOptionButton {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionButton *dummy;
	KQStyleOptionButton();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONBUTTON



#ifndef QSTYLEOPTIONFOCUSRECT
#define QSTYLEOPTIONFOCUSRECT
class DummyQStyleOptionFocusRect : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionFocusRect();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionFocusRect : public QStyleOptionFocusRect {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionFocusRect *dummy;
	KQStyleOptionFocusRect();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONFOCUSRECT



#ifndef QSTYLEOPTIONHEADER
#define QSTYLEOPTIONHEADER
class DummyQStyleOptionHeader : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionHeader();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionHeader : public QStyleOptionHeader {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionHeader *dummy;
	KQStyleOptionHeader();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONHEADER



#ifndef QSTYLEHINTRETURNVARIANT
#define QSTYLEHINTRETURNVARIANT
class DummyQStyleHintReturnVariant : public DummyQStyleHintReturn {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleHintReturnVariant();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleHintReturnVariant : public QStyleHintReturnVariant {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleHintReturnVariant *dummy;
	KQStyleHintReturnVariant();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEHINTRETURNVARIANT



#ifndef QSIGNALMAPPER
#define QSIGNALMAPPER
class DummyQSignalMapper : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSignalMapper();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSignalMapper : public QSignalMapper {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSignalMapper *dummy;
	KQSignalMapper(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSIGNALMAPPER



#ifndef QCOMPLETER
#define QCOMPLETER
class DummyQCompleter : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQCompleter();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQCompleter : public QCompleter {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQCompleter *dummy;
	KQCompleter(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QCOMPLETER



#ifndef QTEXTFRAMEFORMAT
#define QTEXTFRAMEFORMAT
class DummyQTextFrameFormat : public DummyQTextFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextFrameFormat();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextFrameFormat : public QTextFrameFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextFrameFormat *dummy;
	KQTextFrameFormat();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTFRAMEFORMAT



#ifndef QSHOWEVENT
#define QSHOWEVENT
class DummyQShowEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQShowEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQShowEvent : public QShowEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQShowEvent *dummy;
	KQShowEvent();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSHOWEVENT



#ifndef QSOUND
#define QSOUND
class DummyQSound : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSound();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSound : public QSound {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSound *dummy;
	KQSound(const QString filename, QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSOUND



#ifndef QOBJECTCLEANUPHANDLER
#define QOBJECTCLEANUPHANDLER
class DummyQObjectCleanupHandler : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQObjectCleanupHandler();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQObjectCleanupHandler : public QObjectCleanupHandler {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQObjectCleanupHandler *dummy;
	KQObjectCleanupHandler();
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QOBJECTCLEANUPHANDLER



#ifndef QGRAPHICSPIXMAPITEM
#define QGRAPHICSPIXMAPITEM
class DummyQGraphicsPixmapItem : public DummyQGraphicsItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsPixmapItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsPixmapItem : public QGraphicsPixmapItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsPixmapItem *dummy;
	KQGraphicsPixmapItem(QGraphicsItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSPIXMAPITEM



#ifndef QFOCUSEVENT
#define QFOCUSEVENT
class DummyQFocusEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQFocusEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQFocusEvent : public QFocusEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQFocusEvent *dummy;
	KQFocusEvent(QFocusEvent::Type type, Qt::FocusReason reason);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QFOCUSEVENT



#ifndef QSTYLEOPTIONPROGRESSBAR
#define QSTYLEOPTIONPROGRESSBAR
class DummyQStyleOptionProgressBar : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionProgressBar();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionProgressBar : public QStyleOptionProgressBar {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionProgressBar *dummy;
	KQStyleOptionProgressBar();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONPROGRESSBAR



#ifndef QACTIONEVENT
#define QACTIONEVENT
class DummyQActionEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQActionEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQActionEvent : public QActionEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQActionEvent *dummy;
	KQActionEvent(int type, QAction* action, QAction* before);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QACTIONEVENT



#ifndef QACCESSIBLEEVENT
#define QACCESSIBLEEVENT
class DummyQAccessibleEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAccessibleEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAccessibleEvent : public QAccessibleEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAccessibleEvent *dummy;
	KQAccessibleEvent(QAccessibleEvent::Type type, int child);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QACCESSIBLEEVENT



#ifndef QDATAWIDGETMAPPER
#define QDATAWIDGETMAPPER
class DummyQDataWidgetMapper : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *current_index_changed_func;
	DummyQDataWidgetMapper();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool currentIndexChangedSlot(int index);
};

class KQDataWidgetMapper : public QDataWidgetMapper {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDataWidgetMapper *dummy;
	KQDataWidgetMapper(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QDATAWIDGETMAPPER



#ifndef QPRINTER
#define QPRINTER
class DummyQPrinter : public DummyQPaintDevice {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPrinter();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPrinter : public QPrinter {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPrinter *dummy;
	KQPrinter(QPrinter::PrinterMode mode);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPRINTER



#ifndef QSTATUSTIPEVENT
#define QSTATUSTIPEVENT
class DummyQStatusTipEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStatusTipEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStatusTipEvent : public QStatusTipEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStatusTipEvent *dummy;
	KQStatusTipEvent(const QString tip);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTATUSTIPEVENT



#ifndef QTIMEREVENT
#define QTIMEREVENT
class DummyQTimerEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTimerEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTimerEvent : public QTimerEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTimerEvent *dummy;
	KQTimerEvent(int timerId);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTIMEREVENT



#ifndef QGENERICRETURNARGUMENT
#define QGENERICRETURNARGUMENT
class DummyQGenericReturnArgument : public DummyQGenericArgument {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGenericReturnArgument();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGenericReturnArgument : public QGenericReturnArgument {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGenericReturnArgument *dummy;
	KQGenericReturnArgument(const char* name, void* data);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGENERICRETURNARGUMENT



#ifndef QIMAGE
#define QIMAGE
class DummyQImage : public DummyQPaintDevice {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQImage();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQImage : public QImage {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQImage *dummy;
	KQImage();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QIMAGE



#ifndef QABSTRACTSTATE
#define QABSTRACTSTATE
class DummyQAbstractState : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *entered_func;
	knh_Func_t *exited_func;
	DummyQAbstractState();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool enteredSlot();
	bool exitedSlot();
};

class KQAbstractState : public QAbstractState {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractState *dummy;

	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTSTATE



#ifndef QNETWORKSESSION
#define QNETWORKSESSION
class DummyQNetworkSession : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *closed_func;
	knh_Func_t *error_func;
	knh_Func_t *new_configuration_activated_func;
	knh_Func_t *opened_func;
	knh_Func_t *preferred_configuration_changed_func;
	knh_Func_t *state_changed_func;
	DummyQNetworkSession();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool closedSlot();
	bool errorSlot(QNetworkSession::SessionError error);
	bool newConfigurationActivatedSlot();
	bool openedSlot();
	bool preferredConfigurationChangedSlot(const QNetworkConfiguration config, bool isSeamless);
	bool stateChangedSlot(QNetworkSession::State state);
};

class KQNetworkSession : public QNetworkSession {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQNetworkSession *dummy;
	KQNetworkSession(const QNetworkConfiguration connectionConfig, QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QNETWORKSESSION



#ifndef QACTIONGROUP
#define QACTIONGROUP
class DummyQActionGroup : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *hovered_func;
	knh_Func_t *triggered_func;
	DummyQActionGroup();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool hoveredSlot(QAction* action);
	bool triggeredSlot(QAction* action);
};

class KQActionGroup : public QActionGroup {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQActionGroup *dummy;
	KQActionGroup(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QACTIONGROUP



#ifndef QABSTRACTGRAPHICSSHAPEITEM
#define QABSTRACTGRAPHICSSHAPEITEM
class DummyQAbstractGraphicsShapeItem : public DummyQGraphicsItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAbstractGraphicsShapeItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAbstractGraphicsShapeItem : public QAbstractGraphicsShapeItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractGraphicsShapeItem *dummy;
	KQAbstractGraphicsShapeItem(QGraphicsItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QABSTRACTGRAPHICSSHAPEITEM



#ifndef QICONENGINEV2
#define QICONENGINEV2
class DummyQIconEngineV2 : public DummyQIconEngine {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQIconEngineV2();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQIconEngineV2 : public QIconEngineV2 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQIconEngineV2 *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QICONENGINEV2



#ifndef QHIDEEVENT
#define QHIDEEVENT
class DummyQHideEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQHideEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQHideEvent : public QHideEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQHideEvent *dummy;
	KQHideEvent();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QHIDEEVENT



#ifndef QRESIZEEVENT
#define QRESIZEEVENT
class DummyQResizeEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQResizeEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQResizeEvent : public QResizeEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQResizeEvent *dummy;
	KQResizeEvent(const QSize size, const QSize oldSize);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QRESIZEEVENT



#ifndef QNETWORKACCESSMANAGER
#define QNETWORKACCESSMANAGER
class DummyQNetworkAccessManager : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *authentication_required_func;
	knh_Func_t *finished_func;
	knh_Func_t *network_accessible_changed_func;
	knh_Func_t *proxy_authentication_required_func;
	knh_Func_t *ssl_errors_func;
	DummyQNetworkAccessManager();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool authenticationRequiredSlot(QNetworkReply* reply, QAuthenticator* authenticator);
	bool finishedSlot(QNetworkReply* reply);
	bool networkAccessibleChangedSlot(QNetworkAccessManager::NetworkAccessibility accessible);
	bool proxyAuthenticationRequiredSlot(const QNetworkProxy proxy, QAuthenticator* authenticator);
	bool sslErrorsSlot(QNetworkReply* reply, const QList<QSslError> errors);
};

class KQNetworkAccessManager : public QNetworkAccessManager {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQNetworkAccessManager *dummy;
	KQNetworkAccessManager(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QNETWORKACCESSMANAGER



#ifndef QABSTRACTITEMDELEGATE
#define QABSTRACTITEMDELEGATE
class DummyQAbstractItemDelegate : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *close_editor_func;
	knh_Func_t *commit_data_func;
	knh_Func_t *size_hint_changed_func;
	DummyQAbstractItemDelegate();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool closeEditorSlot(QWidget* editor, QAbstractItemDelegate::EndEditHint hint);
	bool commitDataSlot(QWidget* editor);
	bool sizeHintChangedSlot(const QModelIndex index);
};

class KQAbstractItemDelegate : public QAbstractItemDelegate {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractItemDelegate *dummy;
	KQAbstractItemDelegate(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTITEMDELEGATE



#ifndef QMOVEEVENT
#define QMOVEEVENT
class DummyQMoveEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQMoveEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQMoveEvent : public QMoveEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMoveEvent *dummy;
	KQMoveEvent(const QPoint pos, const QPoint oldPos);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QMOVEEVENT



#ifndef QGRAPHICSSCENE
#define QGRAPHICSSCENE
class DummyQGraphicsScene : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *context_menu_event_func;
	knh_Func_t *drag_enter_event_func;
	knh_Func_t *drag_leave_event_func;
	knh_Func_t *drag_move_event_func;
	knh_Func_t *drop_event_func;
	knh_Func_t *focus_in_event_func;
	knh_Func_t *focus_out_event_func;
	knh_Func_t *help_event_func;
	knh_Func_t *input_method_event_func;
	knh_Func_t *key_press_event_func;
	knh_Func_t *key_release_event_func;
	knh_Func_t *mouse_double_click_event_func;
	knh_Func_t *mouse_move_event_func;
	knh_Func_t *mouse_press_event_func;
	knh_Func_t *mouse_release_event_func;
	knh_Func_t *wheel_event_func;
	knh_Func_t *changed_func;
	knh_Func_t *scene_rect_changed_func;
	knh_Func_t *selection_changed_func;
	DummyQGraphicsScene();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
	bool contextMenuEventDummy(QGraphicsSceneContextMenuEvent* contextMenuEvent);
	bool dragEnterEventDummy(QGraphicsSceneDragDropEvent* event);
	bool dragLeaveEventDummy(QGraphicsSceneDragDropEvent* event);
	bool dragMoveEventDummy(QGraphicsSceneDragDropEvent* event);
	bool dropEventDummy(QGraphicsSceneDragDropEvent* event);
	bool focusInEventDummy(QFocusEvent* focusEvent);
	bool focusOutEventDummy(QFocusEvent* focusEvent);
	bool helpEventDummy(QGraphicsSceneHelpEvent* helpEvent);
	bool inputMethodEventDummy(QInputMethodEvent* event);
	bool keyPressEventDummy(QKeyEvent* keyEvent);
	bool keyReleaseEventDummy(QKeyEvent* keyEvent);
	bool mouseDoubleClickEventDummy(QGraphicsSceneMouseEvent* mouseEvent);
	bool mouseMoveEventDummy(QGraphicsSceneMouseEvent* mouseEvent);
	bool mousePressEventDummy(QGraphicsSceneMouseEvent* mouseEvent);
	bool mouseReleaseEventDummy(QGraphicsSceneMouseEvent* mouseEvent);
	bool wheelEventDummy(QGraphicsSceneWheelEvent* wheelEvent);
public slots:
	bool changedSlot(const QList<QRectF> region);
	bool sceneRectChangedSlot(const QRectF rect);
	bool selectionChangedSlot();
};

class KQGraphicsScene : public QGraphicsScene {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsScene *dummy;
	KQGraphicsScene(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSSCENE



#ifndef QGRAPHICSSCENEEVENT
#define QGRAPHICSSCENEEVENT
class DummyQGraphicsSceneEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsSceneEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsSceneEvent : public QGraphicsSceneEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsSceneEvent *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSSCENEEVENT



#ifndef QSTYLEOPTIONTOOLBOX
#define QSTYLEOPTIONTOOLBOX
class DummyQStyleOptionToolBox : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionToolBox();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionToolBox : public QStyleOptionToolBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionToolBox *dummy;
	KQStyleOptionToolBox();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONTOOLBOX



#ifndef QDRAG
#define QDRAG
class DummyQDrag : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *action_changed_func;
	knh_Func_t *target_changed_func;
	DummyQDrag();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool actionChangedSlot(Qt::DropAction action);
	bool targetChangedSlot(QWidget* new_Target);
};

class KQDrag : public QDrag {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDrag *dummy;
	KQDrag(QWidget* dragSource);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QDRAG



#ifndef QPOLYGONF
#define QPOLYGONF
class DummyQPolygonF {//: public DummyQVector {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPolygonF();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void connection(QObject *o);
};

class KQPolygonF : public QPolygonF {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPolygonF *dummy;
	KQPolygonF();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPOLYGONF



#ifndef QGRAPHICSEFFECT
#define QGRAPHICSEFFECT
class DummyQGraphicsEffect : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *enabled_changed_func;
	DummyQGraphicsEffect();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool enabledChangedSlot(bool enabled);
};

class KQGraphicsEffect : public QGraphicsEffect {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsEffect *dummy;
	KQGraphicsEffect(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSEFFECT



#ifndef QLIBRARY
#define QLIBRARY
class DummyQLibrary : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQLibrary();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQLibrary : public QLibrary {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQLibrary *dummy;
	KQLibrary(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QLIBRARY



#ifndef QNETWORKCOOKIEJAR
#define QNETWORKCOOKIEJAR
class DummyQNetworkCookieJar : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQNetworkCookieJar();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQNetworkCookieJar : public QNetworkCookieJar {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQNetworkCookieJar *dummy;
	KQNetworkCookieJar(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QNETWORKCOOKIEJAR



#ifndef QABSTRACTTEXTDOCUMENTLAYOUT
#define QABSTRACTTEXTDOCUMENTLAYOUT
class DummyQAbstractTextDocumentLayout : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *document_size_changed_func;
	knh_Func_t *page_count_changed_func;
	knh_Func_t *update_func;
	knh_Func_t *update_block_func;
	DummyQAbstractTextDocumentLayout();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool documentSizeChangedSlot(const QSizeF new_Size);
	bool pageCountChangedSlot(int new_Pages);
	bool updateSlot(const QRectF rect);
	bool updateBlockSlot(const QTextBlock block);
};

class KQAbstractTextDocumentLayout : public QAbstractTextDocumentLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractTextDocumentLayout *dummy;
	KQAbstractTextDocumentLayout(QTextDocument* document);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTTEXTDOCUMENTLAYOUT



#ifndef QIODEVICE
#define QIODEVICE
class DummyQIODevice : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *about_to_close_func;
	knh_Func_t *bytes_written_func;
	knh_Func_t *read_channel_finished_func;
	knh_Func_t *ready_read_func;
	DummyQIODevice();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool aboutToCloseSlot();
	bool bytesWrittenSlot(qint64 bytes);
	bool readChannelFinishedSlot();
	bool readyReadSlot();
};

class KQIODevice : public QIODevice {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQIODevice *dummy;
	KQIODevice();
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QIODEVICE



#ifndef QTHREADPOOL
#define QTHREADPOOL
class DummyQThreadPool : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQThreadPool();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQThreadPool : public QThreadPool {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQThreadPool *dummy;
	KQThreadPool(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTHREADPOOL



#ifndef QCLOSEEVENT
#define QCLOSEEVENT
class DummyQCloseEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQCloseEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQCloseEvent : public QCloseEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQCloseEvent *dummy;
	KQCloseEvent();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QCLOSEEVENT



#ifndef QSTYLEPAINTER
#define QSTYLEPAINTER
class DummyQStylePainter : public DummyQPainter {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStylePainter();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStylePainter : public QStylePainter {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStylePainter *dummy;
	KQStylePainter();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEPAINTER



#ifndef QHELPEVENT
#define QHELPEVENT
class DummyQHelpEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQHelpEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQHelpEvent : public QHelpEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQHelpEvent *dummy;
	KQHelpEvent(QHelpEvent::Type type, const QPoint pos, const QPoint globalPos);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QHELPEVENT



#ifndef QSTYLE
#define QSTYLE
class DummyQStyle : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyle();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyle : public QStyle {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyle *dummy;
	KQStyle();
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSTYLE



#ifndef QTEXTOBJECT
#define QTEXTOBJECT
class DummyQTextObject : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextObject();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextObject : public QTextObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextObject *dummy;

	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTEXTOBJECT



#ifndef QTEXTCHARFORMAT
#define QTEXTCHARFORMAT
class DummyQTextCharFormat : public DummyQTextFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextCharFormat();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextCharFormat : public QTextCharFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextCharFormat *dummy;
	KQTextCharFormat();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTCHARFORMAT



#ifndef QGESTUREEVENT
#define QGESTUREEVENT
class DummyQGestureEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGestureEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGestureEvent : public QGestureEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGestureEvent *dummy;
	KQGestureEvent(const QList<QGesture*> gestures);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGESTUREEVENT



#ifndef QACCESSIBLEINTERFACE
#define QACCESSIBLEINTERFACE
class DummyQAccessibleInterface : public DummyQAccessible {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAccessibleInterface();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAccessibleInterface : public QAccessibleInterface {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAccessibleInterface *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QACCESSIBLEINTERFACE



#ifndef QSTYLEOPTIONTAB
#define QSTYLEOPTIONTAB
class DummyQStyleOptionTab : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionTab();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionTab : public QStyleOptionTab {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionTab *dummy;
	KQStyleOptionTab();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONTAB



#ifndef QWEBPAGE
#define QWEBPAGE
class DummyQWebPage : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *contents_changed_func;
	knh_Func_t *database_quota_exceeded_func;
	knh_Func_t *download_requested_func;
	knh_Func_t *frame_created_func;
	knh_Func_t *geometry_change_requested_func;
	knh_Func_t *link_clicked_func;
	knh_Func_t *link_hovered_func;
	knh_Func_t *load_finished_func;
	knh_Func_t *load_progress_func;
	knh_Func_t *load_started_func;
	knh_Func_t *menu_bar_visibility_change_requested_func;
	knh_Func_t *micro_focus_changed_func;
	knh_Func_t *print_requested_func;
	knh_Func_t *repaint_requested_func;
	knh_Func_t *restore_frame_state_requested_func;
	knh_Func_t *save_frame_state_requested_func;
	knh_Func_t *scroll_requested_func;
	knh_Func_t *selection_changed_func;
	knh_Func_t *status_bar_message_func;
	knh_Func_t *status_bar_visibility_change_requested_func;
	knh_Func_t *tool_bar_visibility_change_requested_func;
	knh_Func_t *unsupported_content_func;
	knh_Func_t *window_close_requested_func;
	DummyQWebPage();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool contentsChangedSlot();
	bool databaseQuotaExceededSlot(QWebFrame* frame, QString databaseName);
	bool downloadRequestedSlot(const QNetworkRequest request);
	bool frameCreatedSlot(QWebFrame* frame);
	bool geometryChangeRequestedSlot(const QRect geom);
	bool linkClickedSlot(const QUrl url);
	bool linkHoveredSlot(const QString link, const QString title, const QString textContent);
	bool loadFinishedSlot(bool ok);
	bool loadProgressSlot(int progress);
	bool loadStartedSlot();
	bool menuBarVisibilityChangeRequestedSlot(bool visible);
	bool microFocusChangedSlot();
	bool printRequestedSlot(QWebFrame* frame);
	bool repaintRequestedSlot(const QRect dirtyRect);
	bool restoreFrameStateRequestedSlot(QWebFrame* frame);
	bool saveFrameStateRequestedSlot(QWebFrame* frame, QWebHistoryItem* item);
	bool scrollRequestedSlot(int dx, int dy, const QRect rectToScroll);
	bool selectionChangedSlot();
	bool statusBarMessageSlot(const QString text);
	bool statusBarVisibilityChangeRequestedSlot(bool visible);
	bool toolBarVisibilityChangeRequestedSlot(bool visible);
	bool unsupportedContentSlot(QNetworkReply* reply);
	bool windowCloseRequestedSlot();
};

class KQWebPage : public QWebPage {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWebPage *dummy;
	KQWebPage(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QWEBPAGE



#ifndef QSTYLEHINTRETURNMASK
#define QSTYLEHINTRETURNMASK
class DummyQStyleHintReturnMask : public DummyQStyleHintReturn {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleHintReturnMask();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleHintReturnMask : public QStyleHintReturnMask {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleHintReturnMask *dummy;
	KQStyleHintReturnMask();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEHINTRETURNMASK



#ifndef QSTYLEOPTIONDOCKWIDGET
#define QSTYLEOPTIONDOCKWIDGET
class DummyQStyleOptionDockWidget : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionDockWidget();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionDockWidget : public QStyleOptionDockWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionDockWidget *dummy;
	KQStyleOptionDockWidget();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONDOCKWIDGET



#ifndef QABSTRACTEVENTDISPATCHER
#define QABSTRACTEVENTDISPATCHER
class DummyQAbstractEventDispatcher : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *about_to_block_func;
	knh_Func_t *awake_func;
	DummyQAbstractEventDispatcher();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool aboutToBlockSlot();
	bool awakeSlot();
};

class KQAbstractEventDispatcher : public QAbstractEventDispatcher {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractEventDispatcher *dummy;
	KQAbstractEventDispatcher(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTEVENTDISPATCHER



#ifndef QPOLYGON
#define QPOLYGON
class DummyQPolygon {//: public DummyQVector {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPolygon();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void connection(QObject *o);
};

class KQPolygon : public QPolygon {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPolygon *dummy;
	KQPolygon();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPOLYGON



#ifndef QGRAPHICSLAYOUT
#define QGRAPHICSLAYOUT
class DummyQGraphicsLayout : public DummyQGraphicsLayoutItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsLayout();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsLayout : public QGraphicsLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsLayout *dummy;
	KQGraphicsLayout(QGraphicsLayoutItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSLAYOUT



#ifndef QSTYLEOPTIONRUBBERBAND
#define QSTYLEOPTIONRUBBERBAND
class DummyQStyleOptionRubberBand : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionRubberBand();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionRubberBand : public QStyleOptionRubberBand {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionRubberBand *dummy;
	KQStyleOptionRubberBand();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONRUBBERBAND



#ifndef QEVENTLOOP
#define QEVENTLOOP
class DummyQEventLoop : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQEventLoop();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQEventLoop : public QEventLoop {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQEventLoop *dummy;
	KQEventLoop(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QEVENTLOOP



#ifndef QMOVIE
#define QMOVIE
class DummyQMovie : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *error_func;
	knh_Func_t *finished_func;
	knh_Func_t *frame_changed_func;
	knh_Func_t *resized_func;
	knh_Func_t *started_func;
	knh_Func_t *state_changed_func;
	knh_Func_t *updated_func;
	DummyQMovie();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool errorSlot(QImageReader::ImageReaderError error);
	bool finishedSlot();
	bool frameChangedSlot(int frameNumber);
	bool resizedSlot(const QSize size);
	bool startedSlot();
	bool stateChangedSlot(QMovie::MovieState state);
	bool updatedSlot(const QRect rect);
};

class KQMovie : public QMovie {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMovie *dummy;
	KQMovie(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QMOVIE



#ifndef QCHILDEVENT
#define QCHILDEVENT
class DummyQChildEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQChildEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQChildEvent : public QChildEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQChildEvent *dummy;
	KQChildEvent(QChildEvent::Type type, QObject* child);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QCHILDEVENT



#ifndef QMIMEDATA
#define QMIMEDATA
class DummyQMimeData : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQMimeData();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQMimeData : public QMimeData {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMimeData *dummy;
	KQMimeData();
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QMIMEDATA



#ifndef QTIMELINE
#define QTIMELINE
class DummyQTimeLine : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *finished_func;
	knh_Func_t *frame_changed_func;
	knh_Func_t *state_changed_func;
	knh_Func_t *value_changed_func;
	DummyQTimeLine();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool finishedSlot();
	bool frameChangedSlot(int frame);
	bool stateChangedSlot(QTimeLine::State new_State);
	bool valueChangedSlot(qreal value);
};

class KQTimeLine : public QTimeLine {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTimeLine *dummy;
	KQTimeLine(int duration, QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTIMELINE



#ifndef QACTION
#define QACTION
class DummyQAction : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *changed_func;
	knh_Func_t *hovered_func;
	knh_Func_t *toggled_func;
	knh_Func_t *triggered_func;
	DummyQAction();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool changedSlot();
	bool hoveredSlot();
	bool toggledSlot(bool checked);
	bool triggeredSlot(bool checked);
};

class KQAction : public QAction {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAction *dummy;
	KQAction(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QACTION



#ifndef QGRAPHICSLINEITEM
#define QGRAPHICSLINEITEM
class DummyQGraphicsLineItem : public DummyQGraphicsItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsLineItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsLineItem : public QGraphicsLineItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsLineItem *dummy;
	KQGraphicsLineItem(QGraphicsItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSLINEITEM



#ifndef QABSTRACTTRANSITION
#define QABSTRACTTRANSITION
class DummyQAbstractTransition : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *triggered_func;
	DummyQAbstractTransition();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool triggeredSlot();
};

class KQAbstractTransition : public QAbstractTransition {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractTransition *dummy;
	KQAbstractTransition(QState* sourceState);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTTRANSITION



#ifndef QGRAPHICSITEMGROUP
#define QGRAPHICSITEMGROUP
class DummyQGraphicsItemGroup : public DummyQGraphicsItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsItemGroup();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsItemGroup : public QGraphicsItemGroup {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsItemGroup *dummy;
	KQGraphicsItemGroup(QGraphicsItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSITEMGROUP



#ifndef QGRAPHICSTRANSFORM
#define QGRAPHICSTRANSFORM
class DummyQGraphicsTransform : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsTransform();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsTransform : public QGraphicsTransform {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsTransform *dummy;
	KQGraphicsTransform(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSTRANSFORM



#ifndef QABSTRACTITEMMODEL
#define QABSTRACTITEMMODEL
class DummyQAbstractItemModel : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *columns_about_to_be_inserted_func;
	knh_Func_t *columns_about_to_be_moved_func;
	knh_Func_t *columns_about_to_be_removed_func;
	knh_Func_t *columns_inserted_func;
	knh_Func_t *columns_moved_func;
	knh_Func_t *columns_removed_func;
	knh_Func_t *data_changed_func;
	knh_Func_t *header_data_changed_func;
	knh_Func_t *layout_about_to_be_changed_func;
	knh_Func_t *layout_changed_func;
	knh_Func_t *model_about_to_be_reset_func;
	knh_Func_t *model_reset_func;
	knh_Func_t *rows_about_to_be_inserted_func;
	knh_Func_t *rows_about_to_be_moved_func;
	knh_Func_t *rows_about_to_be_removed_func;
	knh_Func_t *rows_inserted_func;
	knh_Func_t *rows_moved_func;
	knh_Func_t *rows_removed_func;
	DummyQAbstractItemModel();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool columnsAboutToBeInsertedSlot(const QModelIndex parent, int start, int end);
	bool columnsAboutToBeMovedSlot(const QModelIndex sourceParent, int sourceStart, int sourceEnd, const QModelIndex destinationParent, int destinationColumn);
	bool columnsAboutToBeRemovedSlot(const QModelIndex parent, int start, int end);
	bool columnsInsertedSlot(const QModelIndex parent, int start, int end);
	bool columnsMovedSlot(const QModelIndex sourceParent, int sourceStart, int sourceEnd, const QModelIndex destinationParent, int destinationColumn);
	bool columnsRemovedSlot(const QModelIndex parent, int start, int end);
	bool dataChangedSlot(const QModelIndex topLeft, const QModelIndex bottomRight);
	bool headerDataChangedSlot(Qt::Orientation orientation, int first, int last);
	bool layoutAboutToBeChangedSlot();
	bool layoutChangedSlot();
	bool modelAboutToBeResetSlot();
	bool modelResetSlot();
	bool rowsAboutToBeInsertedSlot(const QModelIndex parent, int start, int end);
	bool rowsAboutToBeMovedSlot(const QModelIndex sourceParent, int sourceStart, int sourceEnd, const QModelIndex destinationParent, int destinationRow);
	bool rowsAboutToBeRemovedSlot(const QModelIndex parent, int start, int end);
	bool rowsInsertedSlot(const QModelIndex parent, int start, int end);
	bool rowsMovedSlot(const QModelIndex sourceParent, int sourceStart, int sourceEnd, const QModelIndex destinationParent, int destinationRow);
	bool rowsRemovedSlot(const QModelIndex parent, int start, int end);
};

class KQAbstractItemModel : public QAbstractItemModel {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractItemModel *dummy;
	KQAbstractItemModel(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTITEMMODEL



#ifndef QPAINTEVENT
#define QPAINTEVENT
class DummyQPaintEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPaintEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPaintEvent : public QPaintEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPaintEvent *dummy;
	KQPaintEvent(const QRegion paintRegion);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPAINTEVENT



#ifndef QHOVEREVENT
#define QHOVEREVENT
class DummyQHoverEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQHoverEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQHoverEvent : public QHoverEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQHoverEvent *dummy;
	KQHoverEvent(QHoverEvent::Type type, const QPoint pos, const QPoint oldPos);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QHOVEREVENT



#ifndef QVALIDATOR
#define QVALIDATOR
class DummyQValidator : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQValidator();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQValidator : public QValidator {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQValidator *dummy;
	KQValidator(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QVALIDATOR



#ifndef QSYSTEMTRAYICON
#define QSYSTEMTRAYICON
class DummyQSystemTrayIcon : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *activated_func;
	knh_Func_t *message_clicked_func;
	DummyQSystemTrayIcon();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool activatedSlot(QSystemTrayIcon::ActivationReason reason);
	bool messageClickedSlot();
};

class KQSystemTrayIcon : public QSystemTrayIcon {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSystemTrayIcon *dummy;
	KQSystemTrayIcon(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSYSTEMTRAYICON



#ifndef QINPUTMETHODEVENT
#define QINPUTMETHODEVENT
class DummyQInputMethodEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQInputMethodEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQInputMethodEvent : public QInputMethodEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQInputMethodEvent *dummy;
	KQInputMethodEvent();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QINPUTMETHODEVENT



#ifndef QWINDOWSTATECHANGEEVENT
#define QWINDOWSTATECHANGEEVENT
class DummyQWindowStateChangeEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWindowStateChangeEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWindowStateChangeEvent : public QWindowStateChangeEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWindowStateChangeEvent *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QWINDOWSTATECHANGEEVENT



#ifndef QCONICALGRADIENT
#define QCONICALGRADIENT
class DummyQConicalGradient : public DummyQGradient {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQConicalGradient();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQConicalGradient : public QConicalGradient {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQConicalGradient *dummy;
	KQConicalGradient();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QCONICALGRADIENT



#ifndef QSTYLEOPTIONMENUITEM
#define QSTYLEOPTIONMENUITEM
class DummyQStyleOptionMenuItem : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionMenuItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionMenuItem : public QStyleOptionMenuItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionMenuItem *dummy;
	KQStyleOptionMenuItem();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONMENUITEM



#ifndef QSTYLEOPTIONCOMPLEX
#define QSTYLEOPTIONCOMPLEX
class DummyQStyleOptionComplex : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionComplex();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionComplex : public QStyleOptionComplex {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionComplex *dummy;
	KQStyleOptionComplex(int version, int type);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONCOMPLEX



#ifndef QLAYOUT
#define QLAYOUT
class DummyQLayout : public DummyQObject, public DummyQLayoutItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQLayout();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQLayout : public QLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQLayout *dummy;
	KQLayout(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QLAYOUT



#ifndef QGRAPHICSOBJECT
#define QGRAPHICSOBJECT
class DummyQGraphicsObject : public DummyQObject, public DummyQGraphicsItem {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *enabled_changed_func;
	knh_Func_t *opacity_changed_func;
	knh_Func_t *parent_changed_func;
	knh_Func_t *rotation_changed_func;
	knh_Func_t *scale_changed_func;
	knh_Func_t *visible_changed_func;
	knh_Func_t *x_changed_func;
	knh_Func_t *y_changed_func;
	knh_Func_t *z_changed_func;
	DummyQGraphicsObject();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool enabledChangedSlot();
	bool opacityChangedSlot();
	bool parentChangedSlot();
	bool rotationChangedSlot();
	bool scaleChangedSlot();
	bool visibleChangedSlot();
	bool xChangedSlot();
	bool yChangedSlot();
	bool zChangedSlot();
};

class KQGraphicsObject : public QGraphicsObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsObject *dummy;
	KQGraphicsObject(QGraphicsItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSOBJECT



#ifndef QUNDOGROUP
#define QUNDOGROUP
class DummyQUndoGroup : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *active_stack_changed_func;
	knh_Func_t *can_redo_changed_func;
	knh_Func_t *can_undo_changed_func;
	knh_Func_t *clean_changed_func;
	knh_Func_t *index_changed_func;
	knh_Func_t *redo_text_changed_func;
	knh_Func_t *undo_text_changed_func;
	DummyQUndoGroup();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool activeStackChangedSlot(QUndoStack* stack);
	bool canRedoChangedSlot(bool canRedo);
	bool canUndoChangedSlot(bool canUndo);
	bool cleanChangedSlot(bool clean);
	bool indexChangedSlot(int idx);
	bool redoTextChangedSlot(const QString redoText);
	bool undoTextChangedSlot(const QString undoText);
};

class KQUndoGroup : public QUndoGroup {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQUndoGroup *dummy;
	KQUndoGroup(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QUNDOGROUP



#ifndef QWIDGET
#define QWIDGET
class DummyQWidget : public DummyQObject, public DummyQPaintDevice {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *action_event_func;
	knh_Func_t *change_event_func;
	knh_Func_t *close_event_func;
	knh_Func_t *context_menu_event_func;
	knh_Func_t *drag_enter_event_func;
	knh_Func_t *drag_leave_event_func;
	knh_Func_t *drag_move_event_func;
	knh_Func_t *drop_event_func;
	knh_Func_t *enter_event_func;
	knh_Func_t *focus_in_event_func;
	knh_Func_t *focus_out_event_func;
	knh_Func_t *hide_event_func;
	knh_Func_t *input_method_event_func;
	knh_Func_t *key_press_event_func;
	knh_Func_t *key_release_event_func;
	knh_Func_t *leave_event_func;
	knh_Func_t *mouse_double_click_event_func;
	knh_Func_t *mouse_move_event_func;
	knh_Func_t *mouse_press_event_func;
	knh_Func_t *mouse_release_event_func;
	knh_Func_t *move_event_func;
	knh_Func_t *paint_event_func;
	knh_Func_t *resize_event_func;
	knh_Func_t *show_event_func;
	knh_Func_t *tablet_event_func;
	knh_Func_t *wheel_event_func;
	knh_Func_t *custom_context_menu_requested_func;
	DummyQWidget();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
	bool actionEventDummy(QActionEvent* event);
	bool changeEventDummy(QEvent* event);
	bool closeEventDummy(QCloseEvent* event);
	bool contextMenuEventDummy(QContextMenuEvent* event);
	bool dragEnterEventDummy(QDragEnterEvent* event);
	bool dragLeaveEventDummy(QDragLeaveEvent* event);
	bool dragMoveEventDummy(QDragMoveEvent* event);
	bool dropEventDummy(QDropEvent* event);
	bool enterEventDummy(QEvent* event);
	bool focusInEventDummy(QFocusEvent* event);
	bool focusOutEventDummy(QFocusEvent* event);
	bool hideEventDummy(QHideEvent* event);
	bool inputMethodEventDummy(QInputMethodEvent* event);
	bool keyPressEventDummy(QKeyEvent* event);
	bool keyReleaseEventDummy(QKeyEvent* event);
	bool leaveEventDummy(QEvent* event);
	bool mouseDoubleClickEventDummy(QMouseEvent* event);
	bool mouseMoveEventDummy(QMouseEvent* event);
	bool mousePressEventDummy(QMouseEvent* event);
	bool mouseReleaseEventDummy(QMouseEvent* event);
	bool moveEventDummy(QMoveEvent* event);
	bool paintEventDummy(QPaintEvent* event);
	bool resizeEventDummy(QResizeEvent* event);
	bool showEventDummy(QShowEvent* event);
	bool tabletEventDummy(QTabletEvent* event);
	bool wheelEventDummy(QWheelEvent* event);
public slots:
	bool customContextMenuRequestedSlot(const QPoint pos);
};

class KQWidget : public QWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWidget *dummy;
	KQWidget(QWidget* parent, Qt::WindowFlags f);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QWIDGET



#ifndef QPIXMAP
#define QPIXMAP
class DummyQPixmap : public DummyQPaintDevice {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPixmap();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPixmap : public QPixmap {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPixmap *dummy;
	KQPixmap();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPIXMAP



#ifndef QLOCALSERVER
#define QLOCALSERVER
class DummyQLocalServer : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *new_connection_func;
	DummyQLocalServer();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool newConnectionSlot();
};

class KQLocalServer : public QLocalServer {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQLocalServer *dummy;
	KQLocalServer(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QLOCALSERVER



#ifndef QWIDGETITEM
#define QWIDGETITEM
class DummyQWidgetItem : public DummyQLayoutItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWidgetItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWidgetItem : public QWidgetItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWidgetItem *dummy;
	KQWidgetItem(QWidget* widget);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QWIDGETITEM



#ifndef QSTYLEOPTIONGRAPHICSITEM
#define QSTYLEOPTIONGRAPHICSITEM
class DummyQStyleOptionGraphicsItem : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionGraphicsItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionGraphicsItem : public QStyleOptionGraphicsItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionGraphicsItem *dummy;
	KQStyleOptionGraphicsItem();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONGRAPHICSITEM



#ifndef QSTYLEOPTIONVIEWITEM
#define QSTYLEOPTIONVIEWITEM
class DummyQStyleOptionViewItem : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionViewItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionViewItem : public QStyleOptionViewItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionViewItem *dummy;
	KQStyleOptionViewItem();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONVIEWITEM



#ifndef QWHATSTHISCLICKEDEVENT
#define QWHATSTHISCLICKEDEVENT
class DummyQWhatsThisClickedEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWhatsThisClickedEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWhatsThisClickedEvent : public QWhatsThisClickedEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWhatsThisClickedEvent *dummy;
	KQWhatsThisClickedEvent(const QString href);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QWHATSTHISCLICKEDEVENT



#ifndef QPICTURE
#define QPICTURE
class DummyQPicture : public DummyQPaintDevice {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPicture();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPicture : public QPicture {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPicture *dummy;
	KQPicture(int formatVersion);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QPICTURE



#ifndef QBUTTONGROUP
#define QBUTTONGROUP
class DummyQButtonGroup : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQButtonGroup();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQButtonGroup : public QButtonGroup {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQButtonGroup *dummy;
	KQButtonGroup(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QBUTTONGROUP



#ifndef QFTP
#define QFTP
class DummyQFtp : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *command_finished_func;
	knh_Func_t *command_started_func;
	knh_Func_t *data_transfer_progress_func;
	knh_Func_t *done_func;
	knh_Func_t *list_info_func;
	knh_Func_t *raw_command_reply_func;
	knh_Func_t *ready_read_func;
	knh_Func_t *state_changed_func;
	DummyQFtp();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool commandFinishedSlot(int id, bool error);
	bool commandStartedSlot(int id);
	bool dataTransferProgressSlot(qint64 done, qint64 total);
	bool doneSlot(bool error);
	bool listInfoSlot(const QUrlInfo i);
	bool rawCommandReplySlot(int replyCode, const QString detail);
	bool readyReadSlot();
	bool stateChangedSlot(int state);
};

class KQFtp : public QFtp {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQFtp *dummy;
	KQFtp(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QFTP



#ifndef QTIMER
#define QTIMER
class DummyQTimer : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *timeout_func;
	DummyQTimer();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool timeoutSlot();
};

class KQTimer : public QTimer {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTimer *dummy;
	KQTimer(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTIMER



#ifndef QRADIALGRADIENT
#define QRADIALGRADIENT
class DummyQRadialGradient : public DummyQGradient {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQRadialGradient();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQRadialGradient : public QRadialGradient {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQRadialGradient *dummy;
	KQRadialGradient();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QRADIALGRADIENT



#ifndef QSOCKETNOTIFIER
#define QSOCKETNOTIFIER
class DummyQSocketNotifier : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *activated_func;
	DummyQSocketNotifier();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool activatedSlot(int socket);
};

class KQSocketNotifier : public QSocketNotifier {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSocketNotifier *dummy;
	KQSocketNotifier(int socket, QSocketNotifier::Type type, QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSOCKETNOTIFIER



#ifndef QLINEARGRADIENT
#define QLINEARGRADIENT
class DummyQLinearGradient : public DummyQGradient {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQLinearGradient();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQLinearGradient : public QLinearGradient {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQLinearGradient *dummy;
	KQLinearGradient();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QLINEARGRADIENT



#ifndef QDYNAMICPROPERTYCHANGEEVENT
#define QDYNAMICPROPERTYCHANGEEVENT
class DummyQDynamicPropertyChangeEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQDynamicPropertyChangeEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQDynamicPropertyChangeEvent : public QDynamicPropertyChangeEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDynamicPropertyChangeEvent *dummy;
	KQDynamicPropertyChangeEvent(const QByteArray name);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QDYNAMICPROPERTYCHANGEEVENT



#ifndef QINPUTEVENT
#define QINPUTEVENT
class DummyQInputEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQInputEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQInputEvent : public QInputEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQInputEvent *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QINPUTEVENT



#ifndef QTCPSERVER
#define QTCPSERVER
class DummyQTcpServer : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *new_connection_func;
	DummyQTcpServer();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool newConnectionSlot();
};

class KQTcpServer : public QTcpServer {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTcpServer *dummy;
	KQTcpServer(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTCPSERVER



#ifndef QTHREAD
#define QTHREAD
class DummyQThread : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *finished_func;
	knh_Func_t *started_func;
	knh_Func_t *terminated_func;
	DummyQThread();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool finishedSlot();
	bool startedSlot();
	bool terminatedSlot();
};

class KQThread : public QThread {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQThread *dummy;
	KQThread(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTHREAD



#ifndef QWEBHISTORYINTERFACE
#define QWEBHISTORYINTERFACE
class DummyQWebHistoryInterface : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWebHistoryInterface();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWebHistoryInterface : public QWebHistoryInterface {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWebHistoryInterface *dummy;
	KQWebHistoryInterface(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QWEBHISTORYINTERFACE



#ifndef QCOREAPPLICATION
#define QCOREAPPLICATION
class DummyQCoreApplication : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *about_to_quit_func;
	DummyQCoreApplication();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool aboutToQuitSlot();
};

class KQCoreApplication : public QCoreApplication {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQCoreApplication *dummy;
	KQCoreApplication(int argc, char** argv);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QCOREAPPLICATION



#ifndef QSPACERITEM
#define QSPACERITEM
class DummyQSpacerItem : public DummyQLayoutItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSpacerItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSpacerItem : public QSpacerItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSpacerItem *dummy;
	KQSpacerItem(int w, int h, QSizePolicy::Policy hPolicy, QSizePolicy::Policy vPolicy);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSPACERITEM



#ifndef QTEXTBLOCKFORMAT
#define QTEXTBLOCKFORMAT
class DummyQTextBlockFormat : public DummyQTextFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextBlockFormat();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextBlockFormat : public QTextBlockFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextBlockFormat *dummy;
	KQTextBlockFormat();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTBLOCKFORMAT



#ifndef QTRANSLATOR
#define QTRANSLATOR
class DummyQTranslator : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTranslator();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTranslator : public QTranslator {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTranslator *dummy;
	KQTranslator(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTRANSLATOR



#ifndef QSHAREDMEMORY
#define QSHAREDMEMORY
class DummyQSharedMemory : public DummyQObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSharedMemory();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSharedMemory : public QSharedMemory {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSharedMemory *dummy;
	KQSharedMemory(const QString key, QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSHAREDMEMORY



#ifndef QTEXTLISTFORMAT
#define QTEXTLISTFORMAT
class DummyQTextListFormat : public DummyQTextFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextListFormat();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextListFormat : public QTextListFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextListFormat *dummy;
	KQTextListFormat();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTLISTFORMAT



#ifndef QSHORTCUT
#define QSHORTCUT
class DummyQShortcut : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *activated_func;
	knh_Func_t *activated_ambiguously_func;
	DummyQShortcut();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool activatedSlot();
	bool activatedAmbiguouslySlot();
};

class KQShortcut : public QShortcut {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQShortcut *dummy;
	KQShortcut(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSHORTCUT



#ifndef QDROPEVENT
#define QDROPEVENT
class DummyQDropEvent : public DummyQEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQDropEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQDropEvent : public QDropEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDropEvent *dummy;
	KQDropEvent(const QPoint pos, Qt::DropActions actions, const QMimeData* data, Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, QDropEvent::Type type);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QDROPEVENT



#ifndef QSTYLEOPTIONFRAME
#define QSTYLEOPTIONFRAME
class DummyQStyleOptionFrame : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionFrame();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionFrame : public QStyleOptionFrame {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionFrame *dummy;
	KQStyleOptionFrame();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONFRAME



#ifndef QSTYLEOPTIONTABWIDGETFRAME
#define QSTYLEOPTIONTABWIDGETFRAME
class DummyQStyleOptionTabWidgetFrame : public DummyQStyleOption {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionTabWidgetFrame();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionTabWidgetFrame : public QStyleOptionTabWidgetFrame {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionTabWidgetFrame *dummy;
	KQStyleOptionTabWidgetFrame();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONTABWIDGETFRAME



#ifndef QTEXTDOCUMENT
#define QTEXTDOCUMENT
class DummyQTextDocument : public DummyQObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *block_count_changed_func;
	knh_Func_t *contents_change_func;
	knh_Func_t *contents_changed_func;
	knh_Func_t *cursor_position_changed_func;
	knh_Func_t *document_layout_changed_func;
	knh_Func_t *modification_changed_func;
	knh_Func_t *redo_available_func;
	knh_Func_t *undo_available_func;
	knh_Func_t *undo_command_added_func;
	DummyQTextDocument();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool blockCountChangedSlot(int new_BlockCount);
	bool contentsChangeSlot(int position, int charsRemoved, int charsAdded);
	bool contentsChangedSlot();
	bool cursorPositionChangedSlot(const QTextCursor cursor);
	bool documentLayoutChangedSlot();
	bool modificationChangedSlot(bool changed);
	bool redoAvailableSlot(bool available);
	bool undoAvailableSlot(bool available);
	bool undoCommandAddedSlot();
};

class KQTextDocument : public QTextDocument {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextDocument *dummy;
	KQTextDocument(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTEXTDOCUMENT



#ifndef QSTYLEOPTIONCOMBOBOX
#define QSTYLEOPTIONCOMBOBOX
class DummyQStyleOptionComboBox : public DummyQStyleOptionComplex {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionComboBox();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionComboBox : public QStyleOptionComboBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionComboBox *dummy;
	KQStyleOptionComboBox();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONCOMBOBOX



#ifndef QSTYLEOPTIONTOOLBOXV2
#define QSTYLEOPTIONTOOLBOXV2
class DummyQStyleOptionToolBoxV2 : public DummyQStyleOptionToolBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionToolBoxV2();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionToolBoxV2 : public QStyleOptionToolBoxV2 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionToolBoxV2 *dummy;
	KQStyleOptionToolBoxV2();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONTOOLBOXV2



#ifndef QSTANDARDITEMMODEL
#define QSTANDARDITEMMODEL
class DummyQStandardItemModel : public DummyQAbstractItemModel {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *item_changed_func;
	DummyQStandardItemModel();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool itemChangedSlot(QStandardItem* item);
};

class KQStandardItemModel : public QStandardItemModel {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStandardItemModel *dummy;
	KQStandardItemModel(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSTANDARDITEMMODEL



#ifndef QGRAPHICSSCENEHELPEVENT
#define QGRAPHICSSCENEHELPEVENT
class DummyQGraphicsSceneHelpEvent : public DummyQGraphicsSceneEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsSceneHelpEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsSceneHelpEvent : public QGraphicsSceneHelpEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsSceneHelpEvent *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSSCENEHELPEVENT



#ifndef QBOXLAYOUT
#define QBOXLAYOUT
class DummyQBoxLayout : public DummyQLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQBoxLayout();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQBoxLayout : public QBoxLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQBoxLayout *dummy;
	KQBoxLayout(QBoxLayout::Direction dir, QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QBOXLAYOUT



#ifndef QPRINTPREVIEWWIDGET
#define QPRINTPREVIEWWIDGET
class DummyQPrintPreviewWidget : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *paint_requested_func;
	knh_Func_t *preview_changed_func;
	DummyQPrintPreviewWidget();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool paintRequestedSlot(QPrinter* printer);
	bool previewChangedSlot();
};

class KQPrintPreviewWidget : public QPrintPreviewWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPrintPreviewWidget *dummy;
	KQPrintPreviewWidget(QPrinter* printer, QWidget* parent, Qt::WindowFlags flags);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QPRINTPREVIEWWIDGET



#ifndef QTAPANDHOLDGESTURE
#define QTAPANDHOLDGESTURE
class DummyQTapAndHoldGesture : public DummyQGesture {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTapAndHoldGesture();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTapAndHoldGesture : public QTapAndHoldGesture {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTapAndHoldGesture *dummy;

	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTAPANDHOLDGESTURE



#ifndef QDESKTOPWIDGET
#define QDESKTOPWIDGET
class DummyQDesktopWidget : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *resized_func;
	knh_Func_t *screen_count_changed_func;
	knh_Func_t *work_area_resized_func;
	DummyQDesktopWidget();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool resizedSlot(int screen);
	bool screenCountChangedSlot(int new_Count);
	bool workAreaResizedSlot(int screen);
};

class KQDesktopWidget : public QDesktopWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDesktopWidget *dummy;

	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QDESKTOPWIDGET



#ifndef QLINEEDIT
#define QLINEEDIT
class DummyQLineEdit : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *cursor_position_changed_func;
	knh_Func_t *editing_finished_func;
	knh_Func_t *return_pressed_func;
	knh_Func_t *selection_changed_func;
	knh_Func_t *text_changed_func;
	knh_Func_t *text_edited_func;
	DummyQLineEdit();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool cursorPositionChangedSlot(int old, int new_);
	bool editingFinishedSlot();
	bool returnPressedSlot();
	bool selectionChangedSlot();
	bool textChangedSlot(const QString text);
	bool textEditedSlot(const QString text);
};

class KQLineEdit : public QLineEdit {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQLineEdit *dummy;
	KQLineEdit(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QLINEEDIT



#ifndef QGRAPHICSANCHORLAYOUT
#define QGRAPHICSANCHORLAYOUT
class DummyQGraphicsAnchorLayout : public DummyQGraphicsLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsAnchorLayout();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsAnchorLayout : public QGraphicsAnchorLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsAnchorLayout *dummy;
	KQGraphicsAnchorLayout(QGraphicsLayoutItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSANCHORLAYOUT



#ifndef QDOUBLEVALIDATOR
#define QDOUBLEVALIDATOR
class DummyQDoubleValidator : public DummyQValidator {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQDoubleValidator();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQDoubleValidator : public QDoubleValidator {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDoubleValidator *dummy;
	KQDoubleValidator(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QDOUBLEVALIDATOR



#ifndef QDIRMODEL
#define QDIRMODEL
class DummyQDirModel : public DummyQAbstractItemModel {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQDirModel();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQDirModel : public QDirModel {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDirModel *dummy;
	KQDirModel(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QDIRMODEL



#ifndef QGRAPHICSSCENEDRAGDROPEVENT
#define QGRAPHICSSCENEDRAGDROPEVENT
class DummyQGraphicsSceneDragDropEvent : public DummyQGraphicsSceneEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsSceneDragDropEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsSceneDragDropEvent : public QGraphicsSceneDragDropEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsSceneDragDropEvent *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSSCENEDRAGDROPEVENT



#ifndef QTOUCHEVENT
#define QTOUCHEVENT
class DummyQTouchEvent : public DummyQInputEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTouchEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTouchEvent : public QTouchEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTouchEvent *dummy;
	KQTouchEvent(QEvent::Type eventType, QTouchEvent::DeviceType deviceType, Qt::KeyboardModifiers modifiers, Qt::TouchPointStates touchPointStates, const QList<QTouchEvent::TouchPoint> touchPoints);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTOUCHEVENT



#ifndef QGRAPHICSCOLORIZEEFFECT
#define QGRAPHICSCOLORIZEEFFECT
class DummyQGraphicsColorizeEffect : public DummyQGraphicsEffect {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *color_changed_func;
	knh_Func_t *strength_changed_func;
	DummyQGraphicsColorizeEffect();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool colorChangedSlot(const QColor color);
	bool strengthChangedSlot(qreal strength);
};

class KQGraphicsColorizeEffect : public QGraphicsColorizeEffect {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsColorizeEffect *dummy;
	KQGraphicsColorizeEffect(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSCOLORIZEEFFECT



#ifndef QMENU
#define QMENU
class DummyQMenu : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *about_to_hide_func;
	knh_Func_t *about_to_show_func;
	knh_Func_t *hovered_func;
	knh_Func_t *triggered_func;
	DummyQMenu();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool aboutToHideSlot();
	bool aboutToShowSlot();
	bool hoveredSlot(QAction* action);
	bool triggeredSlot(QAction* action);
};

class KQMenu : public QMenu {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMenu *dummy;
	KQMenu(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QMENU



#ifndef QFRAME
#define QFRAME
class DummyQFrame : public DummyQWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQFrame();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQFrame : public QFrame {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQFrame *dummy;
	KQFrame(QWidget* parent, Qt::WindowFlags f);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QFRAME



#ifndef QSIGNALTRANSITION
#define QSIGNALTRANSITION
class DummyQSignalTransition : public DummyQAbstractTransition {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSignalTransition();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSignalTransition : public QSignalTransition {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSignalTransition *dummy;
	KQSignalTransition(QState* sourceState);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSIGNALTRANSITION



#ifndef QSTYLEOPTIONTABBARBASEV2
#define QSTYLEOPTIONTABBARBASEV2
class DummyQStyleOptionTabBarBaseV2 : public DummyQStyleOptionTabBarBase {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionTabBarBaseV2();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionTabBarBaseV2 : public QStyleOptionTabBarBaseV2 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionTabBarBaseV2 *dummy;
	KQStyleOptionTabBarBaseV2();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONTABBARBASEV2



#ifndef QWEBVIEW
#define QWEBVIEW
class DummyQWebView : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *icon_changed_func;
	knh_Func_t *link_clicked_func;
	knh_Func_t *load_finished_func;
	knh_Func_t *load_progress_func;
	knh_Func_t *load_started_func;
	knh_Func_t *selection_changed_func;
	knh_Func_t *status_bar_message_func;
	knh_Func_t *title_changed_func;
	knh_Func_t *url_changed_func;
	DummyQWebView();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool iconChangedSlot();
	bool linkClickedSlot(const QUrl url);
	bool loadFinishedSlot(bool ok);
	bool loadProgressSlot(int progress);
	bool loadStartedSlot();
	bool selectionChangedSlot();
	bool statusBarMessageSlot(const QString text);
	bool titleChangedSlot(const QString title);
	bool urlChangedSlot(const QUrl url);
};

class KQWebView : public QWebView {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWebView *dummy;
	KQWebView(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QWEBVIEW



#ifndef QRUBBERBAND
#define QRUBBERBAND
class DummyQRubberBand : public DummyQWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQRubberBand();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQRubberBand : public QRubberBand {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQRubberBand *dummy;
	KQRubberBand(QRubberBand::Shape s, QWidget* p);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QRUBBERBAND



#ifndef QGRAPHICSRECTITEM
#define QGRAPHICSRECTITEM
class DummyQGraphicsRectItem : public DummyQAbstractGraphicsShapeItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsRectItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsRectItem : public QGraphicsRectItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsRectItem *dummy;
	KQGraphicsRectItem(QGraphicsItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSRECTITEM



#ifndef QSTATE
#define QSTATE
class DummyQState : public DummyQAbstractState {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *finished_func;
	knh_Func_t *properties_assigned_func;
	DummyQState();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool finishedSlot();
	bool propertiesAssignedSlot();
};

class KQState : public QState {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQState *dummy;
	KQState(QState* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSTATE



#ifndef QMAINWINDOW
#define QMAINWINDOW
class DummyQMainWindow : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *icon_size_changed_func;
	knh_Func_t *tool_button_style_changed_func;
	DummyQMainWindow();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool iconSizeChangedSlot(const QSize iconSize);
	bool toolButtonStyleChangedSlot(Qt::ToolButtonStyle toolButtonStyle);
};

class KQMainWindow : public QMainWindow {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMainWindow *dummy;
	KQMainWindow(QWidget* parent, Qt::WindowFlags flags);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QMAINWINDOW



#ifndef QABSTRACTLISTMODEL
#define QABSTRACTLISTMODEL
class DummyQAbstractListModel : public DummyQAbstractItemModel {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAbstractListModel();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAbstractListModel : public QAbstractListModel {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractListModel *dummy;
	KQAbstractListModel(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTLISTMODEL



#ifndef QTEXTTABLECELLFORMAT
#define QTEXTTABLECELLFORMAT
class DummyQTextTableCellFormat : public DummyQTextCharFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextTableCellFormat();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextTableCellFormat : public QTextTableCellFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextTableCellFormat *dummy;
	KQTextTableCellFormat();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTTABLECELLFORMAT



#ifndef QGRAPHICSOPACITYEFFECT
#define QGRAPHICSOPACITYEFFECT
class DummyQGraphicsOpacityEffect : public DummyQGraphicsEffect {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *opacity_changed_func;
	knh_Func_t *opacity_mask_changed_func;
	DummyQGraphicsOpacityEffect();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool opacityChangedSlot(qreal opacity);
	bool opacityMaskChangedSlot(const QBrush mask);
};

class KQGraphicsOpacityEffect : public QGraphicsOpacityEffect {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsOpacityEffect *dummy;
	KQGraphicsOpacityEffect(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSOPACITYEFFECT



#ifndef QTEXTFRAME
#define QTEXTFRAME
class DummyQTextFrame : public DummyQTextObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextFrame();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextFrame : public QTextFrame {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextFrame *dummy;
	KQTextFrame(QTextDocument* document);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTEXTFRAME



#ifndef QGRAPHICSSCENEMOVEEVENT
#define QGRAPHICSSCENEMOVEEVENT
class DummyQGraphicsSceneMoveEvent : public DummyQGraphicsSceneEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsSceneMoveEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsSceneMoveEvent : public QGraphicsSceneMoveEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsSceneMoveEvent *dummy;
	KQGraphicsSceneMoveEvent();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSSCENEMOVEEVENT



#ifndef QGRAPHICSDROPSHADOWEFFECT
#define QGRAPHICSDROPSHADOWEFFECT
class DummyQGraphicsDropShadowEffect : public DummyQGraphicsEffect {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *blur_radius_changed_func;
	knh_Func_t *color_changed_func;
	knh_Func_t *offset_changed_func;
	DummyQGraphicsDropShadowEffect();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool blurRadiusChangedSlot(qreal blurRadius);
	bool colorChangedSlot(const QColor color);
	bool offsetChangedSlot(const QPointF offset);
};

class KQGraphicsDropShadowEffect : public QGraphicsDropShadowEffect {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsDropShadowEffect *dummy;
	KQGraphicsDropShadowEffect(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSDROPSHADOWEFFECT



#ifndef QCONTEXTMENUEVENT
#define QCONTEXTMENUEVENT
class DummyQContextMenuEvent : public DummyQInputEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQContextMenuEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQContextMenuEvent : public QContextMenuEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQContextMenuEvent *dummy;
	KQContextMenuEvent(QContextMenuEvent::Reason reason, const QPoint pos, const QPoint globalPos, Qt::KeyboardModifiers modifiers);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QCONTEXTMENUEVENT



#ifndef QFINALSTATE
#define QFINALSTATE
class DummyQFinalState : public DummyQAbstractState {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQFinalState();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQFinalState : public QFinalState {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQFinalState *dummy;
	KQFinalState(QState* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QFINALSTATE



#ifndef QDIALOGBUTTONBOX
#define QDIALOGBUTTONBOX
class DummyQDialogButtonBox : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *accepted_func;
	knh_Func_t *clicked_func;
	knh_Func_t *help_requested_func;
	knh_Func_t *rejected_func;
	DummyQDialogButtonBox();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool acceptedSlot();
	bool clickedSlot(QAbstractButton* button);
	bool helpRequestedSlot();
	bool rejectedSlot();
};

class KQDialogButtonBox : public QDialogButtonBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDialogButtonBox *dummy;
	KQDialogButtonBox(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QDIALOGBUTTONBOX



#ifndef QSTYLEDITEMDELEGATE
#define QSTYLEDITEMDELEGATE
class DummyQStyledItemDelegate : public DummyQAbstractItemDelegate {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyledItemDelegate();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyledItemDelegate : public QStyledItemDelegate {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyledItemDelegate *dummy;
	KQStyledItemDelegate(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSTYLEDITEMDELEGATE



#ifndef QGRIDLAYOUT
#define QGRIDLAYOUT
class DummyQGridLayout : public DummyQLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGridLayout();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGridLayout : public QGridLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGridLayout *dummy;
	KQGridLayout(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRIDLAYOUT



#ifndef QSTYLEOPTIONPROGRESSBARV2
#define QSTYLEOPTIONPROGRESSBARV2
class DummyQStyleOptionProgressBarV2 : public DummyQStyleOptionProgressBar {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionProgressBarV2();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionProgressBarV2 : public QStyleOptionProgressBarV2 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionProgressBarV2 *dummy;
	KQStyleOptionProgressBarV2();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONPROGRESSBARV2



#ifndef QLOCALSOCKET
#define QLOCALSOCKET
class DummyQLocalSocket : public DummyQIODevice {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *connected_func;
	knh_Func_t *disconnected_func;
	knh_Func_t *error_func;
	knh_Func_t *state_changed_func;
	DummyQLocalSocket();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool connectedSlot();
	bool disconnectedSlot();
	bool errorSlot(QLocalSocket::LocalSocketError socketError);
	bool stateChangedSlot(QLocalSocket::LocalSocketState socketState);
};

class KQLocalSocket : public QLocalSocket {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQLocalSocket *dummy;
	KQLocalSocket(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QLOCALSOCKET



#ifndef QGRAPHICSSCALE
#define QGRAPHICSSCALE
class DummyQGraphicsScale : public DummyQGraphicsTransform {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *origin_changed_func;
	knh_Func_t *scale_changed_func;
	knh_Func_t *x_scale_changed_func;
	knh_Func_t *y_scale_changed_func;
	knh_Func_t *z_scale_changed_func;
	DummyQGraphicsScale();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool originChangedSlot();
	bool scaleChangedSlot();
	bool xScaleChangedSlot();
	bool yScaleChangedSlot();
	bool zScaleChangedSlot();
};

class KQGraphicsScale : public QGraphicsScale {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsScale *dummy;
	KQGraphicsScale(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSSCALE



#ifndef QGRAPHICSLINEARLAYOUT
#define QGRAPHICSLINEARLAYOUT
class DummyQGraphicsLinearLayout : public DummyQGraphicsLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsLinearLayout();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsLinearLayout : public QGraphicsLinearLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsLinearLayout *dummy;
	KQGraphicsLinearLayout(QGraphicsLayoutItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSLINEARLAYOUT



#ifndef QABSTRACTPROXYMODEL
#define QABSTRACTPROXYMODEL
class DummyQAbstractProxyModel : public DummyQAbstractItemModel {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAbstractProxyModel();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAbstractProxyModel : public QAbstractProxyModel {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractProxyModel *dummy;
	KQAbstractProxyModel(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTPROXYMODEL



#ifndef QCALENDARWIDGET
#define QCALENDARWIDGET
class DummyQCalendarWidget : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *activated_func;
	knh_Func_t *clicked_func;
	knh_Func_t *current_page_changed_func;
	knh_Func_t *selection_changed_func;
	DummyQCalendarWidget();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool activatedSlot(const QDate date);
	bool clickedSlot(const QDate date);
	bool currentPageChangedSlot(int year, int month);
	bool selectionChangedSlot();
};

class KQCalendarWidget : public QCalendarWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQCalendarWidget *dummy;
	KQCalendarWidget(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QCALENDARWIDGET



#ifndef QABSTRACTSLIDER
#define QABSTRACTSLIDER
class DummyQAbstractSlider : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *action_triggered_func;
	knh_Func_t *range_changed_func;
	knh_Func_t *slider_moved_func;
	knh_Func_t *slider_pressed_func;
	knh_Func_t *slider_released_func;
	knh_Func_t *value_changed_func;
	DummyQAbstractSlider();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool actionTriggeredSlot(int action);
	bool rangeChangedSlot(int min, int max);
	bool sliderMovedSlot(int value);
	bool sliderPressedSlot();
	bool sliderReleasedSlot();
	bool valueChangedSlot(int value);
};

class KQAbstractSlider : public QAbstractSlider {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractSlider *dummy;
	KQAbstractSlider(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTSLIDER



#ifndef QREGEXPVALIDATOR
#define QREGEXPVALIDATOR
class DummyQRegExpValidator : public DummyQValidator {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQRegExpValidator();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQRegExpValidator : public QRegExpValidator {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQRegExpValidator *dummy;
	KQRegExpValidator(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QREGEXPVALIDATOR



#ifndef QABSTRACTTABLEMODEL
#define QABSTRACTTABLEMODEL
class DummyQAbstractTableModel : public DummyQAbstractItemModel {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAbstractTableModel();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAbstractTableModel : public QAbstractTableModel {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractTableModel *dummy;
	KQAbstractTableModel(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTTABLEMODEL



#ifndef QSTATUSBAR
#define QSTATUSBAR
class DummyQStatusBar : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *message_changed_func;
	DummyQStatusBar();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool messageChangedSlot(const QString message);
};

class KQStatusBar : public QStatusBar {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStatusBar *dummy;
	KQStatusBar(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSTATUSBAR



#ifndef QKEYEVENT
#define QKEYEVENT
class DummyQKeyEvent : public DummyQInputEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQKeyEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQKeyEvent : public QKeyEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQKeyEvent *dummy;
	KQKeyEvent(QKeyEvent::Type type, int key, Qt::KeyboardModifiers modifiers, const QString text, bool autorep, ushort count);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QKEYEVENT



#ifndef QABSTRACTBUTTON
#define QABSTRACTBUTTON
class DummyQAbstractButton : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *clicked_func;
	knh_Func_t *pressed_func;
	knh_Func_t *released_func;
	knh_Func_t *toggled_func;
	DummyQAbstractButton();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool clickedSlot(bool checked);
	bool pressedSlot();
	bool releasedSlot();
	bool toggledSlot(bool checked);
};

class KQAbstractButton : public QAbstractButton {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractButton *dummy;
	KQAbstractButton(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTBUTTON



#ifndef QSTYLEOPTIONTITLEBAR
#define QSTYLEOPTIONTITLEBAR
class DummyQStyleOptionTitleBar : public DummyQStyleOptionComplex {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionTitleBar();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionTitleBar : public QStyleOptionTitleBar {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionTitleBar *dummy;
	KQStyleOptionTitleBar();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONTITLEBAR



#ifndef QDRAGMOVEEVENT
#define QDRAGMOVEEVENT
class DummyQDragMoveEvent : public DummyQDropEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQDragMoveEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQDragMoveEvent : public QDragMoveEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDragMoveEvent *dummy;
	KQDragMoveEvent(const QPoint pos, Qt::DropActions actions, const QMimeData* data, Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, QDragMoveEvent::Type type);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QDRAGMOVEEVENT



#ifndef QGRAPHICSPOLYGONITEM
#define QGRAPHICSPOLYGONITEM
class DummyQGraphicsPolygonItem : public DummyQAbstractGraphicsShapeItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsPolygonItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsPolygonItem : public QGraphicsPolygonItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsPolygonItem *dummy;
	KQGraphicsPolygonItem(QGraphicsItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSPOLYGONITEM



#ifndef QCOMBOBOX
#define QCOMBOBOX
class DummyQComboBox : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *edit_text_changed_func;
	DummyQComboBox();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool editTextChangedSlot(const QString text);
};

class KQComboBox : public QComboBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQComboBox *dummy;
	KQComboBox(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QCOMBOBOX



#ifndef QPLAINTEXTDOCUMENTLAYOUT
#define QPLAINTEXTDOCUMENTLAYOUT
class DummyQPlainTextDocumentLayout : public DummyQAbstractTextDocumentLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPlainTextDocumentLayout();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPlainTextDocumentLayout : public QPlainTextDocumentLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPlainTextDocumentLayout *dummy;
	KQPlainTextDocumentLayout(QTextDocument* document);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QPLAINTEXTDOCUMENTLAYOUT



#ifndef QTEXTTABLEFORMAT
#define QTEXTTABLEFORMAT
class DummyQTextTableFormat : public DummyQTextFrameFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextTableFormat();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextTableFormat : public QTextTableFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextTableFormat *dummy;
	KQTextTableFormat();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTTABLEFORMAT



#ifndef QWIZARDPAGE
#define QWIZARDPAGE
class DummyQWizardPage : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *complete_changed_func;
	DummyQWizardPage();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool completeChangedSlot();
};

class KQWizardPage : public QWizardPage {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWizardPage *dummy;
	KQWizardPage(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QWIZARDPAGE



#ifndef QSTYLEOPTIONTABV2
#define QSTYLEOPTIONTABV2
class DummyQStyleOptionTabV2 : public DummyQStyleOptionTab {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionTabV2();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionTabV2 : public QStyleOptionTabV2 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionTabV2 *dummy;
	KQStyleOptionTabV2();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONTABV2



#ifndef QSTYLEOPTIONSIZEGRIP
#define QSTYLEOPTIONSIZEGRIP
class DummyQStyleOptionSizeGrip : public DummyQStyleOptionComplex {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionSizeGrip();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionSizeGrip : public QStyleOptionSizeGrip {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionSizeGrip *dummy;
	KQStyleOptionSizeGrip();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONSIZEGRIP



#ifndef QABSTRACTSOCKET
#define QABSTRACTSOCKET
class DummyQAbstractSocket : public DummyQIODevice {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *connected_func;
	knh_Func_t *disconnected_func;
	knh_Func_t *error_func;
	knh_Func_t *host_found_func;
	knh_Func_t *proxy_authentication_required_func;
	knh_Func_t *state_changed_func;
	DummyQAbstractSocket();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool connectedSlot();
	bool disconnectedSlot();
	bool errorSlot(QAbstractSocket::SocketError socketError);
	bool hostFoundSlot();
	bool proxyAuthenticationRequiredSlot(const QNetworkProxy proxy, QAuthenticator* authenticator);
	bool stateChangedSlot(QAbstractSocket::SocketState socketState);
};

class KQAbstractSocket : public QAbstractSocket {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractSocket *dummy;
	KQAbstractSocket(QAbstractSocket::SocketType socketType, QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTSOCKET



#ifndef QSTYLEOPTIONVIEWITEMV2
#define QSTYLEOPTIONVIEWITEMV2
class DummyQStyleOptionViewItemV2 : public DummyQStyleOptionViewItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionViewItemV2();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionViewItemV2 : public QStyleOptionViewItemV2 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionViewItemV2 *dummy;
	KQStyleOptionViewItemV2();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONVIEWITEMV2



#ifndef QGRAPHICSTEXTITEM
#define QGRAPHICSTEXTITEM
class DummyQGraphicsTextItem : public DummyQGraphicsObject {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *link_activated_func;
	knh_Func_t *link_hovered_func;
	DummyQGraphicsTextItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool linkActivatedSlot(const QString link);
	bool linkHoveredSlot(const QString link);
};

class KQGraphicsTextItem : public QGraphicsTextItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsTextItem *dummy;
	KQGraphicsTextItem(QGraphicsItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSTEXTITEM



#ifndef QGRAPHICSELLIPSEITEM
#define QGRAPHICSELLIPSEITEM
class DummyQGraphicsEllipseItem : public DummyQAbstractGraphicsShapeItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsEllipseItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsEllipseItem : public QGraphicsEllipseItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsEllipseItem *dummy;
	KQGraphicsEllipseItem(QGraphicsItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSELLIPSEITEM



#ifndef QSTYLEOPTIONSPINBOX
#define QSTYLEOPTIONSPINBOX
class DummyQStyleOptionSpinBox : public DummyQStyleOptionComplex {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionSpinBox();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionSpinBox : public QStyleOptionSpinBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionSpinBox *dummy;
	KQStyleOptionSpinBox();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONSPINBOX



#ifndef QSTYLEOPTIONTOOLBUTTON
#define QSTYLEOPTIONTOOLBUTTON
class DummyQStyleOptionToolButton : public DummyQStyleOptionComplex {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionToolButton();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionToolButton : public QStyleOptionToolButton {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionToolButton *dummy;
	KQStyleOptionToolButton();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONTOOLBUTTON



#ifndef QBITMAP
#define QBITMAP
class DummyQBitmap : public DummyQPixmap {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQBitmap();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQBitmap : public QBitmap {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQBitmap *dummy;
	KQBitmap();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QBITMAP



#ifndef QNETWORKDISKCACHE
#define QNETWORKDISKCACHE
class DummyQNetworkDiskCache : public DummyQAbstractNetworkCache {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQNetworkDiskCache();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQNetworkDiskCache : public QNetworkDiskCache {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQNetworkDiskCache *dummy;
	KQNetworkDiskCache(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QNETWORKDISKCACHE



#ifndef QGROUPBOX
#define QGROUPBOX
class DummyQGroupBox : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *clicked_func;
	knh_Func_t *toggled_func;
	DummyQGroupBox();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool clickedSlot(bool checked);
	bool toggledSlot(bool on);
};

class KQGroupBox : public QGroupBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGroupBox *dummy;
	KQGroupBox(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGROUPBOX



#ifndef QSTYLEOPTIONGROUPBOX
#define QSTYLEOPTIONGROUPBOX
class DummyQStyleOptionGroupBox : public DummyQStyleOptionComplex {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionGroupBox();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionGroupBox : public QStyleOptionGroupBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionGroupBox *dummy;
	KQStyleOptionGroupBox();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONGROUPBOX



#ifndef QWIDGETACTION
#define QWIDGETACTION
class DummyQWidgetAction : public DummyQAction {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWidgetAction();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWidgetAction : public QWidgetAction {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWidgetAction *dummy;
	KQWidgetAction(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QWIDGETACTION



#ifndef QTABBAR
#define QTABBAR
class DummyQTabBar : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *current_changed_func;
	knh_Func_t *tab_close_requested_func;
	knh_Func_t *tab_moved_func;
	DummyQTabBar();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool currentChangedSlot(int index);
	bool tabCloseRequestedSlot(int index);
	bool tabMovedSlot(int from, int to);
};

class KQTabBar : public QTabBar {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTabBar *dummy;
	KQTabBar(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTABBAR



#ifndef QGRAPHICSSIMPLETEXTITEM
#define QGRAPHICSSIMPLETEXTITEM
class DummyQGraphicsSimpleTextItem : public DummyQAbstractGraphicsShapeItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsSimpleTextItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsSimpleTextItem : public QGraphicsSimpleTextItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsSimpleTextItem *dummy;
	KQGraphicsSimpleTextItem(QGraphicsItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSSIMPLETEXTITEM



#ifndef QEVENTTRANSITION
#define QEVENTTRANSITION
class DummyQEventTransition : public DummyQAbstractTransition {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQEventTransition();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQEventTransition : public QEventTransition {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQEventTransition *dummy;
	KQEventTransition(QState* sourceState);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QEVENTTRANSITION



#ifndef QHISTORYSTATE
#define QHISTORYSTATE
class DummyQHistoryState : public DummyQAbstractState {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQHistoryState();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQHistoryState : public QHistoryState {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQHistoryState *dummy;
	KQHistoryState(QState* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QHISTORYSTATE



#ifndef QBUFFER
#define QBUFFER
class DummyQBuffer : public DummyQIODevice {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQBuffer();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQBuffer : public QBuffer {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQBuffer *dummy;
	KQBuffer(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QBUFFER



#ifndef QITEMDELEGATE
#define QITEMDELEGATE
class DummyQItemDelegate : public DummyQAbstractItemDelegate {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQItemDelegate();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQItemDelegate : public QItemDelegate {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQItemDelegate *dummy;
	KQItemDelegate(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QITEMDELEGATE



#ifndef QTOOLBAR
#define QTOOLBAR
class DummyQToolBar : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *action_triggered_func;
	knh_Func_t *allowed_areas_changed_func;
	knh_Func_t *icon_size_changed_func;
	knh_Func_t *movable_changed_func;
	knh_Func_t *orientation_changed_func;
	knh_Func_t *tool_button_style_changed_func;
	knh_Func_t *top_level_changed_func;
	knh_Func_t *visibility_changed_func;
	DummyQToolBar();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool actionTriggeredSlot(QAction* action);
	bool allowedAreasChangedSlot(Qt::ToolBarAreas allowedAreas);
	bool iconSizeChangedSlot(const QSize iconSize);
	bool movableChangedSlot(bool movable);
	bool orientationChangedSlot(Qt::Orientation orientation);
	bool toolButtonStyleChangedSlot(Qt::ToolButtonStyle toolButtonStyle);
	bool topLevelChangedSlot(bool topLevel);
	bool visibilityChangedSlot(bool visible);
};

class KQToolBar : public QToolBar {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQToolBar *dummy;
	KQToolBar(const QString title, QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTOOLBAR



#ifndef QINTVALIDATOR
#define QINTVALIDATOR
class DummyQIntValidator : public DummyQValidator {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQIntValidator();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQIntValidator : public QIntValidator {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQIntValidator *dummy;
	KQIntValidator(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QINTVALIDATOR



#ifndef QPROGRESSBAR
#define QPROGRESSBAR
class DummyQProgressBar : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *value_changed_func;
	DummyQProgressBar();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool valueChangedSlot(int value);
};

class KQProgressBar : public QProgressBar {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQProgressBar *dummy;
	KQProgressBar(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QPROGRESSBAR



#ifndef QGRAPHICSSCENERESIZEEVENT
#define QGRAPHICSSCENERESIZEEVENT
class DummyQGraphicsSceneResizeEvent : public DummyQGraphicsSceneEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsSceneResizeEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsSceneResizeEvent : public QGraphicsSceneResizeEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsSceneResizeEvent *dummy;
	KQGraphicsSceneResizeEvent();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSSCENERESIZEEVENT



#ifndef QGRAPHICSSCENEMOUSEEVENT
#define QGRAPHICSSCENEMOUSEEVENT
class DummyQGraphicsSceneMouseEvent : public DummyQGraphicsSceneEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsSceneMouseEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsSceneMouseEvent : public QGraphicsSceneMouseEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsSceneMouseEvent *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSSCENEMOUSEEVENT



#ifndef QTAPGESTURE
#define QTAPGESTURE
class DummyQTapGesture : public DummyQGesture {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTapGesture();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTapGesture : public QTapGesture {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTapGesture *dummy;

	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTAPGESTURE



#ifndef QWHEELEVENT
#define QWHEELEVENT
class DummyQWheelEvent : public DummyQInputEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWheelEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWheelEvent : public QWheelEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWheelEvent *dummy;
	KQWheelEvent(const QPoint pos, int delta, Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, Qt::Orientation orient);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QWHEELEVENT



#ifndef QDOCKWIDGET
#define QDOCKWIDGET
class DummyQDockWidget : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *allowed_areas_changed_func;
	knh_Func_t *dock_location_changed_func;
	knh_Func_t *features_changed_func;
	knh_Func_t *top_level_changed_func;
	knh_Func_t *visibility_changed_func;
	DummyQDockWidget();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool allowedAreasChangedSlot(Qt::DockWidgetAreas allowedAreas);
	bool dockLocationChangedSlot(Qt::DockWidgetArea area);
	bool featuresChangedSlot(QDockWidget::DockWidgetFeatures features);
	bool topLevelChangedSlot(bool topLevel);
	bool visibilityChangedSlot(bool visible);
};

class KQDockWidget : public QDockWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDockWidget *dummy;
	KQDockWidget(const QString title, QWidget* parent, Qt::WindowFlags flags);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QDOCKWIDGET



#ifndef QSWIPEGESTURE
#define QSWIPEGESTURE
class DummyQSwipeGesture : public DummyQGesture {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSwipeGesture();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSwipeGesture : public QSwipeGesture {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSwipeGesture *dummy;

	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSWIPEGESTURE



#ifndef QWEBINSPECTOR
#define QWEBINSPECTOR
class DummyQWebInspector : public DummyQWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQWebInspector();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQWebInspector : public QWebInspector {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWebInspector *dummy;
	KQWebInspector(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QWEBINSPECTOR



#ifndef QTABLETEVENT
#define QTABLETEVENT
class DummyQTabletEvent : public DummyQInputEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTabletEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTabletEvent : public QTabletEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTabletEvent *dummy;
	KQTabletEvent(QTabletEvent::Type type, const QPoint pos, const QPoint globalPos, const QPointF hiResGlobalPos, int device, int pointerType, qreal pressure, int xTilt, int yTilt, qreal tangentialPressure, qreal rotation, int z, Qt::KeyboardModifiers keyState, qint64 uniqueID);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTABLETEVENT



#ifndef QMDISUBWINDOW
#define QMDISUBWINDOW
class DummyQMdiSubWindow : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *about_to_activate_func;
	knh_Func_t *window_state_changed_func;
	DummyQMdiSubWindow();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool aboutToActivateSlot();
	bool windowStateChangedSlot(Qt::WindowStates oldState, Qt::WindowStates new_State);
};

class KQMdiSubWindow : public QMdiSubWindow {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMdiSubWindow *dummy;
	KQMdiSubWindow(QWidget* parent, Qt::WindowFlags flags);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QMDISUBWINDOW



#ifndef QGRAPHICSGRIDLAYOUT
#define QGRAPHICSGRIDLAYOUT
class DummyQGraphicsGridLayout : public DummyQGraphicsLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsGridLayout();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsGridLayout : public QGraphicsGridLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsGridLayout *dummy;
	KQGraphicsGridLayout(QGraphicsLayoutItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSGRIDLAYOUT



#ifndef QACCESSIBLEOBJECT
#define QACCESSIBLEOBJECT
class DummyQAccessibleObject : public DummyQAccessibleInterface {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAccessibleObject();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAccessibleObject : public QAccessibleObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAccessibleObject *dummy;
	KQAccessibleObject(QObject* object);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QACCESSIBLEOBJECT



#ifndef QTEXTBLOCKGROUP
#define QTEXTBLOCKGROUP
class DummyQTextBlockGroup : public DummyQTextObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextBlockGroup();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextBlockGroup : public QTextBlockGroup {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextBlockGroup *dummy;

	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTEXTBLOCKGROUP



#ifndef QSTYLEOPTIONTABWIDGETFRAMEV2
#define QSTYLEOPTIONTABWIDGETFRAMEV2
class DummyQStyleOptionTabWidgetFrameV2 : public DummyQStyleOptionTabWidgetFrame {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionTabWidgetFrameV2();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionTabWidgetFrameV2 : public QStyleOptionTabWidgetFrameV2 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionTabWidgetFrameV2 *dummy;
	KQStyleOptionTabWidgetFrameV2();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONTABWIDGETFRAMEV2



#ifndef QSTYLEOPTIONFRAMEV2
#define QSTYLEOPTIONFRAMEV2
class DummyQStyleOptionFrameV2 : public DummyQStyleOptionFrame {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionFrameV2();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionFrameV2 : public QStyleOptionFrameV2 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionFrameV2 *dummy;
	KQStyleOptionFrameV2();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONFRAMEV2



#ifndef QNETWORKREPLY
#define QNETWORKREPLY
class DummyQNetworkReply : public DummyQIODevice {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *download_progress_func;
	knh_Func_t *error_func;
	knh_Func_t *finished_func;
	knh_Func_t *meta_data_changed_func;
	knh_Func_t *ssl_errors_func;
	knh_Func_t *upload_progress_func;
	DummyQNetworkReply();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool downloadProgressSlot(qint64 bytesReceived, qint64 bytesTotal);
	bool errorSlot(QNetworkReply::NetworkError code);
	bool finishedSlot();
	bool metaDataChangedSlot();
	bool sslErrorsSlot(const QList<QSslError> errors);
	bool uploadProgressSlot(qint64 bytesSent, qint64 bytesTotal);
};

class KQNetworkReply : public QNetworkReply {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQNetworkReply *dummy;

	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QNETWORKREPLY



#ifndef QSPLITTERHANDLE
#define QSPLITTERHANDLE
class DummyQSplitterHandle : public DummyQWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSplitterHandle();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSplitterHandle : public QSplitterHandle {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSplitterHandle *dummy;
	KQSplitterHandle(Qt::Orientation orientation, QSplitter* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSPLITTERHANDLE



#ifndef QAPPLICATION
#define QAPPLICATION
class DummyQApplication : public DummyQCoreApplication {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *focus_changed_func;
	knh_Func_t *font_database_changed_func;
	knh_Func_t *last_window_closed_func;
	DummyQApplication();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool focusChangedSlot(QWidget* old, QWidget* now);
	bool fontDatabaseChangedSlot();
	bool lastWindowClosedSlot();
};

class KQApplication : public QApplication {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQApplication *dummy;
	KQApplication(int argc, char** argv);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QAPPLICATION



#ifndef QGRAPHICSSCENEHOVEREVENT
#define QGRAPHICSSCENEHOVEREVENT
class DummyQGraphicsSceneHoverEvent : public DummyQGraphicsSceneEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsSceneHoverEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsSceneHoverEvent : public QGraphicsSceneHoverEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsSceneHoverEvent *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSSCENEHOVEREVENT



#ifndef QDIALOG
#define QDIALOG
class DummyQDialog : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *accepted_func;
	knh_Func_t *finished_func;
	knh_Func_t *rejected_func;
	DummyQDialog();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool acceptedSlot();
	bool finishedSlot(int result);
	bool rejectedSlot();
};

class KQDialog : public QDialog {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDialog *dummy;
	KQDialog(QWidget* parent, Qt::WindowFlags f);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QDIALOG



#ifndef QGRAPHICSBLUREFFECT
#define QGRAPHICSBLUREFFECT
class DummyQGraphicsBlurEffect : public DummyQGraphicsEffect {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *blur_hints_changed_func;
	knh_Func_t *blur_radius_changed_func;
	DummyQGraphicsBlurEffect();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool blurHintsChangedSlot(QGraphicsBlurEffect::BlurHints hints);
	bool blurRadiusChangedSlot(qreal radius);
};

class KQGraphicsBlurEffect : public QGraphicsBlurEffect {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsBlurEffect *dummy;
	KQGraphicsBlurEffect(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSBLUREFFECT



#ifndef QSIZEGRIP
#define QSIZEGRIP
class DummyQSizeGrip : public DummyQWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSizeGrip();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSizeGrip : public QSizeGrip {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSizeGrip *dummy;
	KQSizeGrip(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSIZEGRIP



#ifndef QPROXYMODEL
#define QPROXYMODEL
class DummyQProxyModel : public DummyQAbstractItemModel {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQProxyModel();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQProxyModel : public QProxyModel {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQProxyModel *dummy;
	KQProxyModel(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QPROXYMODEL



#ifndef QSTYLEOPTIONSLIDER
#define QSTYLEOPTIONSLIDER
class DummyQStyleOptionSlider : public DummyQStyleOptionComplex {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionSlider();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionSlider : public QStyleOptionSlider {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionSlider *dummy;
	KQStyleOptionSlider();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONSLIDER



#ifndef QSPLASHSCREEN
#define QSPLASHSCREEN
class DummyQSplashScreen : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *message_changed_func;
	DummyQSplashScreen();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool messageChangedSlot(const QString message);
};

class KQSplashScreen : public QSplashScreen {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSplashScreen *dummy;
	KQSplashScreen(const QPixmap pixmap, Qt::WindowFlags f);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSPLASHSCREEN



#ifndef QMENUBAR
#define QMENUBAR
class DummyQMenuBar : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *hovered_func;
	knh_Func_t *triggered_func;
	DummyQMenuBar();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool hoveredSlot(QAction* action);
	bool triggeredSlot(QAction* action);
};

class KQMenuBar : public QMenuBar {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMenuBar *dummy;
	KQMenuBar(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QMENUBAR



#ifndef QABSTRACTSPINBOX
#define QABSTRACTSPINBOX
class DummyQAbstractSpinBox : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *editing_finished_func;
	DummyQAbstractSpinBox();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool editingFinishedSlot();
};

class KQAbstractSpinBox : public QAbstractSpinBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractSpinBox *dummy;
	KQAbstractSpinBox(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTSPINBOX



#ifndef QTEXTIMAGEFORMAT
#define QTEXTIMAGEFORMAT
class DummyQTextImageFormat : public DummyQTextCharFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextImageFormat();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextImageFormat : public QTextImageFormat {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextImageFormat *dummy;
	KQTextImageFormat();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QTEXTIMAGEFORMAT



#ifndef QCOMMONSTYLE
#define QCOMMONSTYLE
class DummyQCommonStyle : public DummyQStyle {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQCommonStyle();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQCommonStyle : public QCommonStyle {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQCommonStyle *dummy;
	KQCommonStyle();
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QCOMMONSTYLE



#ifndef QGRAPHICSROTATION
#define QGRAPHICSROTATION
class DummyQGraphicsRotation : public DummyQGraphicsTransform {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *angle_changed_func;
	knh_Func_t *axis_changed_func;
	knh_Func_t *origin_changed_func;
	DummyQGraphicsRotation();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool angleChangedSlot();
	bool axisChangedSlot();
	bool originChangedSlot();
};

class KQGraphicsRotation : public QGraphicsRotation {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsRotation *dummy;
	KQGraphicsRotation(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSROTATION



#ifndef QFORMLAYOUT
#define QFORMLAYOUT
class DummyQFormLayout : public DummyQLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQFormLayout();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQFormLayout : public QFormLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQFormLayout *dummy;
	KQFormLayout(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QFORMLAYOUT



#ifndef QFOCUSFRAME
#define QFOCUSFRAME
class DummyQFocusFrame : public DummyQWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQFocusFrame();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQFocusFrame : public QFocusFrame {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQFocusFrame *dummy;
	KQFocusFrame(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QFOCUSFRAME



#ifndef QPROCESS
#define QPROCESS
class DummyQProcess : public DummyQIODevice {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *error_func;
	knh_Func_t *finished_func;
	knh_Func_t *ready_read_standard_error_func;
	knh_Func_t *ready_read_standard_output_func;
	knh_Func_t *started_func;
	knh_Func_t *state_changed_func;
	DummyQProcess();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool errorSlot(QProcess::ProcessError error);
	bool finishedSlot(int exitCode, QProcess::ExitStatus exitStatus);
	bool readyReadStandardErrorSlot();
	bool readyReadStandardOutputSlot();
	bool startedSlot();
	bool stateChangedSlot(QProcess::ProcessState new_State);
};

class KQProcess : public QProcess {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQProcess *dummy;
	KQProcess(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QPROCESS



#ifndef QGRAPHICSSCENEWHEELEVENT
#define QGRAPHICSSCENEWHEELEVENT
class DummyQGraphicsSceneWheelEvent : public DummyQGraphicsSceneEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsSceneWheelEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsSceneWheelEvent : public QGraphicsSceneWheelEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsSceneWheelEvent *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSSCENEWHEELEVENT



#ifndef QTABWIDGET
#define QTABWIDGET
class DummyQTabWidget : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *current_changed_func;
	knh_Func_t *tab_close_requested_func;
	DummyQTabWidget();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool currentChangedSlot(int index);
	bool tabCloseRequestedSlot(int index);
};

class KQTabWidget : public QTabWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTabWidget *dummy;
	KQTabWidget(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTABWIDGET



#ifndef QGRAPHICSWIDGET
#define QGRAPHICSWIDGET
class DummyQGraphicsWidget : public DummyQGraphicsObject, public DummyQGraphicsLayoutItem {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *change_event_func;
	knh_Func_t *close_event_func;
	knh_Func_t *grab_keyboard_event_func;
	knh_Func_t *grab_mouse_event_func;
	knh_Func_t *hide_event_func;
	knh_Func_t *move_event_func;
	knh_Func_t *polish_event_func;
	knh_Func_t *resize_event_func;
	knh_Func_t *show_event_func;
	knh_Func_t *ungrab_keyboard_event_func;
	knh_Func_t *ungrab_mouse_event_func;
	knh_Func_t *window_frame_event_func;
	knh_Func_t *geometry_changed_func;
	DummyQGraphicsWidget();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
	bool changeEventDummy(QEvent* event);
	bool closeEventDummy(QCloseEvent* event);
	bool grabKeyboardEventDummy(QEvent* event);
	bool grabMouseEventDummy(QEvent* event);
	bool hideEventDummy(QHideEvent* event);
	bool moveEventDummy(QGraphicsSceneMoveEvent* event);
	bool polishEventDummy();
	bool resizeEventDummy(QGraphicsSceneResizeEvent* event);
	bool showEventDummy(QShowEvent* event);
	bool ungrabKeyboardEventDummy(QEvent* event);
	bool ungrabMouseEventDummy(QEvent* event);
	bool windowFrameEventDummy(QEvent* event);
public slots:
	bool geometryChangedSlot();
};

class KQGraphicsWidget : public QGraphicsWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsWidget *dummy;
	KQGraphicsWidget(QGraphicsItem* parent, Qt::WindowFlags wFlags);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSWIDGET



#ifndef QPANGESTURE
#define QPANGESTURE
class DummyQPanGesture : public DummyQGesture {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPanGesture();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPanGesture : public QPanGesture {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPanGesture *dummy;

	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QPANGESTURE



#ifndef QMOUSEEVENT
#define QMOUSEEVENT
class DummyQMouseEvent : public DummyQInputEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQMouseEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQMouseEvent : public QMouseEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMouseEvent *dummy;
	KQMouseEvent(QMouseEvent::Type type, const QPoint position, Qt::MouseButton button, Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QMOUSEEVENT



#ifndef QWORKSPACE
#define QWORKSPACE
class DummyQWorkspace : public DummyQWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *window_activated_func;
	DummyQWorkspace();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool windowActivatedSlot(QWidget* w);
};

class KQWorkspace : public QWorkspace {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWorkspace *dummy;
	KQWorkspace(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QWORKSPACE



#ifndef QGRAPHICSPATHITEM
#define QGRAPHICSPATHITEM
class DummyQGraphicsPathItem : public DummyQAbstractGraphicsShapeItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsPathItem();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsPathItem : public QGraphicsPathItem {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsPathItem *dummy;
	KQGraphicsPathItem(QGraphicsItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSPATHITEM



#ifndef QPINCHGESTURE
#define QPINCHGESTURE
class DummyQPinchGesture : public DummyQGesture {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPinchGesture();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPinchGesture : public QPinchGesture {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPinchGesture *dummy;

	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QPINCHGESTURE



#ifndef QGRAPHICSSCENECONTEXTMENUEVENT
#define QGRAPHICSSCENECONTEXTMENUEVENT
class DummyQGraphicsSceneContextMenuEvent : public DummyQGraphicsSceneEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsSceneContextMenuEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsSceneContextMenuEvent : public QGraphicsSceneContextMenuEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsSceneContextMenuEvent *dummy;

	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QGRAPHICSSCENECONTEXTMENUEVENT



#ifndef QWIZARD
#define QWIZARD
class DummyQWizard : public DummyQDialog {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *current_id_changed_func;
	knh_Func_t *custom_button_clicked_func;
	knh_Func_t *help_requested_func;
	knh_Func_t *page_added_func;
	knh_Func_t *page_removed_func;
	DummyQWizard();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool currentIdChangedSlot(int id);
	bool customButtonClickedSlot(int which);
	bool helpRequestedSlot();
	bool pageAddedSlot(int id);
	bool pageRemovedSlot(int id);
};

class KQWizard : public QWizard {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQWizard *dummy;
	KQWizard(QWidget* parent, Qt::WindowFlags flags);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QWIZARD



#ifndef QSLIDER
#define QSLIDER
class DummyQSlider : public DummyQAbstractSlider {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSlider();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSlider : public QSlider {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSlider *dummy;
	KQSlider(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSLIDER



#ifndef QPRINTPREVIEWDIALOG
#define QPRINTPREVIEWDIALOG
class DummyQPrintPreviewDialog : public DummyQDialog {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *paint_requested_func;
	DummyQPrintPreviewDialog();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool paintRequestedSlot(QPrinter* printer);
};

class KQPrintPreviewDialog : public QPrintPreviewDialog {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPrintPreviewDialog *dummy;
	KQPrintPreviewDialog(QPrinter* printer, QWidget* parent, Qt::WindowFlags flags);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QPRINTPREVIEWDIALOG



#ifndef QPUSHBUTTON
#define QPUSHBUTTON
class DummyQPushButton : public DummyQAbstractButton {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPushButton();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPushButton : public QPushButton {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPushButton *dummy;
	KQPushButton(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QPUSHBUTTON



#ifndef QSTYLEOPTIONFRAMEV3
#define QSTYLEOPTIONFRAMEV3
class DummyQStyleOptionFrameV3 : public DummyQStyleOptionFrameV2 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionFrameV3();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionFrameV3 : public QStyleOptionFrameV3 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionFrameV3 *dummy;
	KQStyleOptionFrameV3();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONFRAMEV3



#ifndef QSTYLEOPTIONTABV3
#define QSTYLEOPTIONTABV3
class DummyQStyleOptionTabV3 : public DummyQStyleOptionTabV2 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionTabV3();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionTabV3 : public QStyleOptionTabV3 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionTabV3 *dummy;
	KQStyleOptionTabV3();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONTABV3



#ifndef QSCROLLBAR
#define QSCROLLBAR
class DummyQScrollBar : public DummyQAbstractSlider {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQScrollBar();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQScrollBar : public QScrollBar {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQScrollBar *dummy;
	KQScrollBar(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSCROLLBAR



#ifndef QPROXYSTYLE
#define QPROXYSTYLE
class DummyQProxyStyle : public DummyQCommonStyle {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQProxyStyle();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQProxyStyle : public QProxyStyle {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQProxyStyle *dummy;
	KQProxyStyle(QStyle* style);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QPROXYSTYLE



#ifndef QACCESSIBLEWIDGET
#define QACCESSIBLEWIDGET
class DummyQAccessibleWidget : public DummyQAccessibleObject {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAccessibleWidget();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAccessibleWidget : public QAccessibleWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAccessibleWidget *dummy;
	KQAccessibleWidget(QWidget* w, QAccessibleWidget::Role role, const QString name);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QACCESSIBLEWIDGET



#ifndef QTEXTTABLE
#define QTEXTTABLE
class DummyQTextTable : public DummyQTextFrame {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextTable();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextTable : public QTextTable {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextTable *dummy;

	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTEXTTABLE



#ifndef QTEXTLIST
#define QTEXTLIST
class DummyQTextList : public DummyQTextBlockGroup {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTextList();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTextList : public QTextList {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextList *dummy;

	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTEXTLIST



#ifndef QLABEL
#define QLABEL
class DummyQLabel : public DummyQFrame {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *link_activated_func;
	knh_Func_t *link_hovered_func;
	DummyQLabel();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool linkActivatedSlot(const QString link);
	bool linkHoveredSlot(const QString link);
};

class KQLabel : public QLabel {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQLabel *dummy;
	KQLabel(QWidget* parent, Qt::WindowFlags f);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QLABEL



#ifndef QTOOLBOX
#define QTOOLBOX
class DummyQToolBox : public DummyQFrame {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *current_changed_func;
	DummyQToolBox();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool currentChangedSlot(int index);
};

class KQToolBox : public QToolBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQToolBox *dummy;
	KQToolBox(QWidget* parent, Qt::WindowFlags f);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTOOLBOX



#ifndef QMOTIFSTYLE
#define QMOTIFSTYLE
class DummyQMotifStyle : public DummyQCommonStyle {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQMotifStyle();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQMotifStyle : public QMotifStyle {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMotifStyle *dummy;
	KQMotifStyle(bool useHighlightCols);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QMOTIFSTYLE



#ifndef QRADIOBUTTON
#define QRADIOBUTTON
class DummyQRadioButton : public DummyQAbstractButton {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQRadioButton();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQRadioButton : public QRadioButton {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQRadioButton *dummy;
	KQRadioButton(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QRADIOBUTTON



#ifndef QDRAGENTEREVENT
#define QDRAGENTEREVENT
class DummyQDragEnterEvent : public DummyQDragMoveEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQDragEnterEvent();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQDragEnterEvent : public QDragEnterEvent {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDragEnterEvent *dummy;
	KQDragEnterEvent(const QPoint point, Qt::DropActions actions, const QMimeData* data, Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers);
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QDRAGENTEREVENT



#ifndef QLCDNUMBER
#define QLCDNUMBER
class DummyQLCDNumber : public DummyQFrame {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *overflow_func;
	DummyQLCDNumber();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool overflowSlot();
};

class KQLCDNumber : public QLCDNumber {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQLCDNumber *dummy;
	KQLCDNumber(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QLCDNUMBER



#ifndef QKEYEVENTTRANSITION
#define QKEYEVENTTRANSITION
class DummyQKeyEventTransition : public DummyQEventTransition {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQKeyEventTransition();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQKeyEventTransition : public QKeyEventTransition {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQKeyEventTransition *dummy;
	KQKeyEventTransition(QState* sourceState);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QKEYEVENTTRANSITION



#ifndef QTOOLBUTTON
#define QTOOLBUTTON
class DummyQToolButton : public DummyQAbstractButton {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *triggered_func;
	DummyQToolButton();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool triggeredSlot(QAction* action);
};

class KQToolButton : public QToolButton {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQToolButton *dummy;
	KQToolButton(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTOOLBUTTON



#ifndef QERRORMESSAGE
#define QERRORMESSAGE
class DummyQErrorMessage : public DummyQDialog {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQErrorMessage();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQErrorMessage : public QErrorMessage {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQErrorMessage *dummy;
	KQErrorMessage(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QERRORMESSAGE



#ifndef QCHECKBOX
#define QCHECKBOX
class DummyQCheckBox : public DummyQAbstractButton {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *state_changed_func;
	DummyQCheckBox();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool stateChangedSlot(int state);
};

class KQCheckBox : public QCheckBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQCheckBox *dummy;
	KQCheckBox(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QCHECKBOX



#ifndef QABSTRACTSCROLLAREA
#define QABSTRACTSCROLLAREA
class DummyQAbstractScrollArea : public DummyQFrame {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *viewport_event_func;
	DummyQAbstractScrollArea();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
	bool viewportEventDummy(QEvent* event);
};

class KQAbstractScrollArea : public QAbstractScrollArea {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractScrollArea *dummy;
	KQAbstractScrollArea(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTSCROLLAREA



#ifndef QDIAL
#define QDIAL
class DummyQDial : public DummyQAbstractSlider {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQDial();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQDial : public QDial {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDial *dummy;
	KQDial(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QDIAL



#ifndef QINPUTDIALOG
#define QINPUTDIALOG
class DummyQInputDialog : public DummyQDialog {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *double_value_changed_func;
	knh_Func_t *double_value_selected_func;
	knh_Func_t *int_value_changed_func;
	knh_Func_t *int_value_selected_func;
	knh_Func_t *text_value_changed_func;
	knh_Func_t *text_value_selected_func;
	DummyQInputDialog();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool doubleValueChangedSlot(double value);
	bool doubleValueSelectedSlot(double value);
	bool intValueChangedSlot(int value);
	bool intValueSelectedSlot(int value);
	bool textValueChangedSlot(const QString text);
	bool textValueSelectedSlot(const QString text);
};

class KQInputDialog : public QInputDialog {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQInputDialog *dummy;
	KQInputDialog(QWidget* parent, Qt::WindowFlags flags);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QINPUTDIALOG



#ifndef QTCPSOCKET
#define QTCPSOCKET
class DummyQTcpSocket : public DummyQAbstractSocket {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTcpSocket();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTcpSocket : public QTcpSocket {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTcpSocket *dummy;
	KQTcpSocket(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTCPSOCKET



#ifndef QPAGESETUPDIALOG
#define QPAGESETUPDIALOG
class DummyQPageSetupDialog : public DummyQDialog {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQPageSetupDialog();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQPageSetupDialog : public QPageSetupDialog {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPageSetupDialog *dummy;
	KQPageSetupDialog(QPrinter* printer, QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QPAGESETUPDIALOG



#ifndef QCOLORDIALOG
#define QCOLORDIALOG
class DummyQColorDialog : public DummyQDialog {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *color_selected_func;
	knh_Func_t *current_color_changed_func;
	DummyQColorDialog();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool colorSelectedSlot(const QColor color);
	bool currentColorChangedSlot(const QColor color);
};

class KQColorDialog : public QColorDialog {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQColorDialog *dummy;
	KQColorDialog(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QCOLORDIALOG



#ifndef QMOUSEEVENTTRANSITION
#define QMOUSEEVENTTRANSITION
class DummyQMouseEventTransition : public DummyQEventTransition {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQMouseEventTransition();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQMouseEventTransition : public QMouseEventTransition {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMouseEventTransition *dummy;
	KQMouseEventTransition(QState* sourceState);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QMOUSEEVENTTRANSITION



#ifndef QDATETIMEEDIT
#define QDATETIMEEDIT
class DummyQDateTimeEdit : public DummyQAbstractSpinBox {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *date_changed_func;
	knh_Func_t *date_time_changed_func;
	knh_Func_t *time_changed_func;
	DummyQDateTimeEdit();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool dateChangedSlot(const QDate date);
	bool dateTimeChangedSlot(const QDateTime datetime);
	bool timeChangedSlot(const QTime time);
};

class KQDateTimeEdit : public QDateTimeEdit {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDateTimeEdit *dummy;
	KQDateTimeEdit(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QDATETIMEEDIT



#ifndef QVBOXLAYOUT
#define QVBOXLAYOUT
class DummyQVBoxLayout : public DummyQBoxLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQVBoxLayout();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQVBoxLayout : public QVBoxLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQVBoxLayout *dummy;
	KQVBoxLayout();
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QVBOXLAYOUT



#ifndef QSTYLEOPTIONVIEWITEMV3
#define QSTYLEOPTIONVIEWITEMV3
class DummyQStyleOptionViewItemV3 : public DummyQStyleOptionViewItemV2 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionViewItemV3();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionViewItemV3 : public QStyleOptionViewItemV3 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionViewItemV3 *dummy;
	KQStyleOptionViewItemV3();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONVIEWITEMV3



#ifndef QFONTCOMBOBOX
#define QFONTCOMBOBOX
class DummyQFontComboBox : public DummyQComboBox {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *current_font_changed_func;
	DummyQFontComboBox();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool currentFontChangedSlot(const QFont font);
};

class KQFontComboBox : public QFontComboBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQFontComboBox *dummy;
	KQFontComboBox(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QFONTCOMBOBOX



#ifndef QUDPSOCKET
#define QUDPSOCKET
class DummyQUdpSocket : public DummyQAbstractSocket {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQUdpSocket();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQUdpSocket : public QUdpSocket {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQUdpSocket *dummy;
	KQUdpSocket(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QUDPSOCKET



#ifndef QMESSAGEBOX
#define QMESSAGEBOX
class DummyQMessageBox : public DummyQDialog {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *button_clicked_func;
	DummyQMessageBox();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool buttonClickedSlot(QAbstractButton* button);
};

class KQMessageBox : public QMessageBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMessageBox *dummy;
	KQMessageBox(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QMESSAGEBOX



#ifndef QPROGRESSDIALOG
#define QPROGRESSDIALOG
class DummyQProgressDialog : public DummyQDialog {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *canceled_func;
	DummyQProgressDialog();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool canceledSlot();
};

class KQProgressDialog : public QProgressDialog {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQProgressDialog *dummy;
	KQProgressDialog(QWidget* parent, Qt::WindowFlags f);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QPROGRESSDIALOG



#ifndef QABSTRACTPRINTDIALOG
#define QABSTRACTPRINTDIALOG
class DummyQAbstractPrintDialog : public DummyQDialog {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQAbstractPrintDialog();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQAbstractPrintDialog : public QAbstractPrintDialog {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractPrintDialog *dummy;
	KQAbstractPrintDialog(QPrinter* printer, QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTPRINTDIALOG



#ifndef QGRAPHICSPROXYWIDGET
#define QGRAPHICSPROXYWIDGET
class DummyQGraphicsProxyWidget : public DummyQGraphicsWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsProxyWidget();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsProxyWidget : public QGraphicsProxyWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsProxyWidget *dummy;
	KQGraphicsProxyWidget(QGraphicsItem* parent, Qt::WindowFlags wFlags);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSPROXYWIDGET



#ifndef QGRAPHICSWEBVIEW
#define QGRAPHICSWEBVIEW
class DummyQGraphicsWebView : public DummyQGraphicsWidget {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *icon_changed_func;
	knh_Func_t *link_clicked_func;
	knh_Func_t *load_finished_func;
	knh_Func_t *load_progress_func;
	knh_Func_t *load_started_func;
	knh_Func_t *status_bar_message_func;
	knh_Func_t *title_changed_func;
	knh_Func_t *url_changed_func;
	DummyQGraphicsWebView();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool iconChangedSlot();
	bool linkClickedSlot(const QUrl url);
	bool loadFinishedSlot(bool ok);
	bool loadProgressSlot(int progress);
	bool loadStartedSlot();
	bool statusBarMessageSlot(const QString text);
	bool titleChangedSlot(const QString title);
	bool urlChangedSlot(const QUrl url);
};

class KQGraphicsWebView : public QGraphicsWebView {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsWebView *dummy;
	KQGraphicsWebView(QGraphicsItem* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSWEBVIEW



#ifndef QSPINBOX
#define QSPINBOX
class DummyQSpinBox : public DummyQAbstractSpinBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSpinBox();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSpinBox : public QSpinBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSpinBox *dummy;
	KQSpinBox(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSPINBOX



#ifndef QDOUBLESPINBOX
#define QDOUBLESPINBOX
class DummyQDoubleSpinBox : public DummyQAbstractSpinBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQDoubleSpinBox();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQDoubleSpinBox : public QDoubleSpinBox {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDoubleSpinBox *dummy;
	KQDoubleSpinBox(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QDOUBLESPINBOX



#ifndef QHBOXLAYOUT
#define QHBOXLAYOUT
class DummyQHBoxLayout : public DummyQBoxLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQHBoxLayout();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQHBoxLayout : public QHBoxLayout {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQHBoxLayout *dummy;
	KQHBoxLayout();
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QHBOXLAYOUT



#ifndef QSPLITTER
#define QSPLITTER
class DummyQSplitter : public DummyQFrame {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *splitter_moved_func;
	DummyQSplitter();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool splitterMovedSlot(int pos, int index);
};

class KQSplitter : public QSplitter {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSplitter *dummy;
	KQSplitter(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSPLITTER



#ifndef QFONTDIALOG
#define QFONTDIALOG
class DummyQFontDialog : public DummyQDialog {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *current_font_changed_func;
	knh_Func_t *font_selected_func;
	DummyQFontDialog();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool currentFontChangedSlot(const QFont font);
	bool fontSelectedSlot(const QFont font);
};

class KQFontDialog : public QFontDialog {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQFontDialog *dummy;
	KQFontDialog(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QFONTDIALOG



#ifndef QSORTFILTERPROXYMODEL
#define QSORTFILTERPROXYMODEL
class DummyQSortFilterProxyModel : public DummyQAbstractProxyModel {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQSortFilterProxyModel();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQSortFilterProxyModel : public QSortFilterProxyModel {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSortFilterProxyModel *dummy;
	KQSortFilterProxyModel(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSORTFILTERPROXYMODEL



#ifndef QSCROLLAREA
#define QSCROLLAREA
class DummyQScrollArea : public DummyQAbstractScrollArea {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQScrollArea();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQScrollArea : public QScrollArea {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQScrollArea *dummy;
	KQScrollArea(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSCROLLAREA



#ifndef QSSLSOCKET
#define QSSLSOCKET
class DummyQSslSocket : public DummyQTcpSocket {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *encrypted_func;
	knh_Func_t *encrypted_bytes_written_func;
	knh_Func_t *mode_changed_func;
	knh_Func_t *peer_verify_error_func;
	knh_Func_t *ssl_errors_func;
	DummyQSslSocket();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool encryptedSlot();
	bool encryptedBytesWrittenSlot(qint64 written);
	bool modeChangedSlot(QSslSocket::SslMode mode);
	bool peerVerifyErrorSlot(const QSslError error);
	bool sslErrorsSlot(const QList<QSslError> errors);
};

class KQSslSocket : public QSslSocket {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQSslSocket *dummy;
	KQSslSocket(QObject* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QSSLSOCKET



#ifndef QTEXTEDIT
#define QTEXTEDIT
class DummyQTextEdit : public DummyQAbstractScrollArea {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *copy_available_func;
	knh_Func_t *current_char_format_changed_func;
	knh_Func_t *cursor_position_changed_func;
	knh_Func_t *redo_available_func;
	knh_Func_t *selection_changed_func;
	knh_Func_t *text_changed_func;
	knh_Func_t *undo_available_func;
	DummyQTextEdit();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool copyAvailableSlot(bool yes);
	bool currentCharFormatChangedSlot(const QTextCharFormat f);
	bool cursorPositionChangedSlot();
	bool redoAvailableSlot(bool available);
	bool selectionChangedSlot();
	bool textChangedSlot();
	bool undoAvailableSlot(bool available);
};

class KQTextEdit : public QTextEdit {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextEdit *dummy;
	KQTextEdit(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTEXTEDIT



#ifndef QSTYLEOPTIONVIEWITEMV4
#define QSTYLEOPTIONVIEWITEMV4
class DummyQStyleOptionViewItemV4 : public DummyQStyleOptionViewItemV3 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQStyleOptionViewItemV4();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQStyleOptionViewItemV4 : public QStyleOptionViewItemV4 {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQStyleOptionViewItemV4 *dummy;
	KQStyleOptionViewItemV4();
	void setSelf(knh_RawPtr_t *ptr);
};

#endif //QSTYLEOPTIONVIEWITEMV4



#ifndef QCOMMANDLINKBUTTON
#define QCOMMANDLINKBUTTON
class DummyQCommandLinkButton : public DummyQPushButton {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQCommandLinkButton();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQCommandLinkButton : public QCommandLinkButton {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQCommandLinkButton *dummy;
	KQCommandLinkButton(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QCOMMANDLINKBUTTON



#ifndef QGRAPHICSVIEW
#define QGRAPHICSVIEW
class DummyQGraphicsView : public DummyQAbstractScrollArea {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQGraphicsView();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQGraphicsView : public QGraphicsView {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQGraphicsView *dummy;
	KQGraphicsView(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QGRAPHICSVIEW



#ifndef QABSTRACTITEMVIEW
#define QABSTRACTITEMVIEW
class DummyQAbstractItemView : public DummyQAbstractScrollArea {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *activated_func;
	knh_Func_t *clicked_func;
	knh_Func_t *double_clicked_func;
	knh_Func_t *entered_func;
	knh_Func_t *pressed_func;
	knh_Func_t *viewport_entered_func;
	DummyQAbstractItemView();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool activatedSlot(const QModelIndex index);
	bool clickedSlot(const QModelIndex index);
	bool doubleClickedSlot(const QModelIndex index);
	bool enteredSlot(const QModelIndex index);
	bool pressedSlot(const QModelIndex index);
	bool viewportEnteredSlot();
};

class KQAbstractItemView : public QAbstractItemView {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQAbstractItemView *dummy;
	KQAbstractItemView(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QABSTRACTITEMVIEW



#ifndef QCDESTYLE
#define QCDESTYLE
class DummyQCDEStyle : public DummyQMotifStyle {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQCDEStyle();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQCDEStyle : public QCDEStyle {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQCDEStyle *dummy;
	KQCDEStyle(bool useHighlightCols);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QCDESTYLE



#ifndef QMDIAREA
#define QMDIAREA
class DummyQMdiArea : public DummyQAbstractScrollArea {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *sub_window_activated_func;
	DummyQMdiArea();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool subWindowActivatedSlot(QMdiSubWindow* window);
};

class KQMdiArea : public QMdiArea {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQMdiArea *dummy;
	KQMdiArea(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QMDIAREA



#ifndef QPLAINTEXTEDIT
#define QPLAINTEXTEDIT
class DummyQPlainTextEdit : public DummyQAbstractScrollArea {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *block_count_changed_func;
	knh_Func_t *copy_available_func;
	knh_Func_t *cursor_position_changed_func;
	knh_Func_t *modification_changed_func;
	knh_Func_t *redo_available_func;
	knh_Func_t *selection_changed_func;
	knh_Func_t *text_changed_func;
	knh_Func_t *undo_available_func;
	knh_Func_t *update_request_func;
	DummyQPlainTextEdit();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool blockCountChangedSlot(int new_BlockCount);
	bool copyAvailableSlot(bool yes);
	bool cursorPositionChangedSlot();
	bool modificationChangedSlot(bool changed);
	bool redoAvailableSlot(bool available);
	bool selectionChangedSlot();
	bool textChangedSlot();
	bool undoAvailableSlot(bool available);
	bool updateRequestSlot(const QRect rect, int dy);
};

class KQPlainTextEdit : public QPlainTextEdit {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPlainTextEdit *dummy;
	KQPlainTextEdit(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QPLAINTEXTEDIT



#ifndef QPRINTDIALOG
#define QPRINTDIALOG
class DummyQPrintDialog : public DummyQAbstractPrintDialog {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *accepted_func;
	DummyQPrintDialog();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool acceptedSlot(QPrinter* printer);
};

class KQPrintDialog : public QPrintDialog {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQPrintDialog *dummy;
	KQPrintDialog(QPrinter* printer, QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QPRINTDIALOG



#ifndef QDATEEDIT
#define QDATEEDIT
class DummyQDateEdit : public DummyQDateTimeEdit {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQDateEdit();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQDateEdit : public QDateEdit {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQDateEdit *dummy;
	KQDateEdit(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QDATEEDIT



#ifndef QTIMEEDIT
#define QTIMEEDIT
class DummyQTimeEdit : public DummyQDateTimeEdit {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTimeEdit();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTimeEdit : public QTimeEdit {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTimeEdit *dummy;
	KQTimeEdit(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTIMEEDIT



#ifndef QCOLUMNVIEW
#define QCOLUMNVIEW
class DummyQColumnView : public DummyQAbstractItemView {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *update_preview_widget_func;
	DummyQColumnView();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool updatePreviewWidgetSlot(const QModelIndex index);
};

class KQColumnView : public QColumnView {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQColumnView *dummy;
	KQColumnView(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QCOLUMNVIEW



#ifndef QTEXTBROWSER
#define QTEXTBROWSER
class DummyQTextBrowser : public DummyQTextEdit {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *anchor_clicked_func;
	knh_Func_t *backward_available_func;
	knh_Func_t *forward_available_func;
	knh_Func_t *history_changed_func;
	knh_Func_t *source_changed_func;
	DummyQTextBrowser();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool anchorClickedSlot(const QUrl link);
	bool backwardAvailableSlot(bool available);
	bool forwardAvailableSlot(bool available);
	bool historyChangedSlot();
	bool sourceChangedSlot(const QUrl src);
};

class KQTextBrowser : public QTextBrowser {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTextBrowser *dummy;
	KQTextBrowser(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTEXTBROWSER



#ifndef QTABLEVIEW
#define QTABLEVIEW
class DummyQTableView : public DummyQAbstractItemView {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	DummyQTableView();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
};

class KQTableView : public QTableView {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTableView *dummy;
	KQTableView(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTABLEVIEW



#ifndef QTREEVIEW
#define QTREEVIEW
class DummyQTreeView : public DummyQAbstractItemView {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *collapsed_func;
	knh_Func_t *expanded_func;
	DummyQTreeView();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool collapsedSlot(const QModelIndex index);
	bool expandedSlot(const QModelIndex index);
};

class KQTreeView : public QTreeView {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTreeView *dummy;
	KQTreeView(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTREEVIEW



#ifndef QHEADERVIEW
#define QHEADERVIEW
class DummyQHeaderView : public DummyQAbstractItemView {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *geometries_changed_func;
	knh_Func_t *section_auto_resize_func;
	knh_Func_t *section_clicked_func;
	knh_Func_t *section_count_changed_func;
	knh_Func_t *section_double_clicked_func;
	knh_Func_t *section_entered_func;
	knh_Func_t *section_handle_double_clicked_func;
	knh_Func_t *section_moved_func;
	knh_Func_t *section_pressed_func;
	knh_Func_t *section_resized_func;
	knh_Func_t *sort_indicator_changed_func;
	DummyQHeaderView();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool geometriesChangedSlot();
	bool sectionAutoResizeSlot(int logicalIndex, QHeaderView::ResizeMode mode);
	bool sectionClickedSlot(int logicalIndex);
	bool sectionCountChangedSlot(int oldCount, int new_Count);
	bool sectionDoubleClickedSlot(int logicalIndex);
	bool sectionEnteredSlot(int logicalIndex);
	bool sectionHandleDoubleClickedSlot(int logicalIndex);
	bool sectionMovedSlot(int logicalIndex, int oldVisualIndex, int new_VisualIndex);
	bool sectionPressedSlot(int logicalIndex);
	bool sectionResizedSlot(int logicalIndex, int oldSize, int new_Size);
	bool sortIndicatorChangedSlot(int logicalIndex, Qt::SortOrder order);
};

class KQHeaderView : public QHeaderView {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQHeaderView *dummy;
	KQHeaderView(Qt::Orientation orientation, QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QHEADERVIEW



#ifndef QTREEWIDGET
#define QTREEWIDGET
class DummyQTreeWidget : public DummyQTreeView {
	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	std::map<std::string, knh_Func_t *> *event_map;
	std::map<std::string, knh_Func_t *> *slot_map;
	knh_Func_t *current_item_changed_func;
	knh_Func_t *item_activated_func;
	knh_Func_t *item_changed_func;
	knh_Func_t *item_clicked_func;
	knh_Func_t *item_collapsed_func;
	knh_Func_t *item_double_clicked_func;
	knh_Func_t *item_entered_func;
	knh_Func_t *item_expanded_func;
	knh_Func_t *item_pressed_func;
	knh_Func_t *item_selection_changed_func;
	DummyQTreeWidget();
	void setSelf(knh_RawPtr_t *ptr);
	bool eventDispatcher(QEvent *event);
	bool addEvent(knh_Func_t *callback_func, std::string str);
	bool signalConnect(knh_Func_t *callback_func, std::string str);
	void reftrace(CTX ctx, knh_RawPtr_t *p FTRARG);
	void connection(QObject *o);
public slots:
	bool currentItemChangedSlot(QTreeWidgetItem* current, QTreeWidgetItem* previous);
	bool itemActivatedSlot(QTreeWidgetItem* item, int column);
	bool itemChangedSlot(QTreeWidgetItem* item, int column);
	bool itemClickedSlot(QTreeWidgetItem* item, int column);
	bool itemCollapsedSlot(QTreeWidgetItem* item);
	bool itemDoubleClickedSlot(QTreeWidgetItem* item, int column);
	bool itemEnteredSlot(QTreeWidgetItem* item, int column);
	bool itemExpandedSlot(QTreeWidgetItem* item);
	bool itemPressedSlot(QTreeWidgetItem* item, int column);
	bool itemSelectionChangedSlot();
};

class KQTreeWidget : public QTreeWidget {
//	Q_OBJECT;
public:
	knh_RawPtr_t *self;
	DummyQTreeWidget *dummy;
	KQTreeWidget(QWidget* parent);
	void setSelf(knh_RawPtr_t *ptr);
	bool event(QEvent *event);
};

#endif //QTREEWIDGET



